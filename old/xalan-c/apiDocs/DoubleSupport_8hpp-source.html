<HTML><HEAD><TITLE>Xalan-C++ API Documentation</TITLE></HEAD>
<BODY>
<h2 align="center">Xalan-C++ API Documentation</h2>
<h3 align="center">The Xalan C++ XSLT Processor Version 1.10</h3>
</BODY>
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>DoubleSupport.hpp</h1><a href="DoubleSupport_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> * Copyright 1999-2004 The Apache Software Foundation.</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</font>
00005 <font class="comment"> * you may not use this file except in compliance with the License.</font>
00006 <font class="comment"> * You may obtain a copy of the License at</font>
00007 <font class="comment"> *</font>
00008 <font class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</font>
00009 <font class="comment"> *</font>
00010 <font class="comment"> * Unless required by applicable law or agreed to in writing, software</font>
00011 <font class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</font>
00012 <font class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</font>
00013 <font class="comment"> * See the License for the specific language governing permissions and</font>
00014 <font class="comment"> * limitations under the License.</font>
00015 <font class="comment"> */</font>
00016 <font class="preprocessor">#if !defined(DOUBLESUPPORT_HEADER_GUARD_1357924680)</font>
<a name="l00017"></a><a class="code" href="DoubleSupport_8hpp.html#a0">00017</a> <font class="preprocessor"></font><font class="preprocessor">#define DOUBLESUPPORT_HEADER_GUARD_1357924680</font>
00018 <font class="preprocessor"></font>
00019 
00020 
00021 <font class="comment">// Base include file.  Must be first.</font>
00022 <font class="preprocessor">#include &lt;<a class="code" href="PlatformSupportDefinitions_8hpp.html">xalanc/PlatformSupport/PlatformSupportDefinitions.hpp</a>&gt;</font>
00023 
00024 
00025 
00026 <font class="preprocessor">#include &lt;cmath&gt;</font>
00027 <font class="preprocessor">#include &lt;functional&gt;</font>
00028 
00029 
00030 
00031 <font class="preprocessor">#include &lt;<a class="code" href="XalanDOMString_8hpp.html">xalanc/XalanDOM/XalanDOMString.hpp</a>&gt;</font>
00032 
00033 
00034 
00035 XALAN_CPP_NAMESPACE_BEGIN
00036 
00037 
00038 
<a name="l00039"></a><a class="code" href="DoubleSupport_8hpp.html#a1">00039</a> <a class="code" href="XSLTInputSource_8hpp.html#a3">XALAN_USING_XERCES</a>(MemoryManager)
00040 
00041 
00042 
00043 <font class="comment">// A class to help us support IEEE 754.</font>
00044 <font class="keyword">class </font>XALAN_PLATFORMSUPPORT_EXPORT DoubleSupport
00045 {
00046 <font class="keyword">public</font>:
00047 
00052     <font class="keyword">static</font> <font class="keywordtype">void</font>
00053     initialize();
00054  
00058     <font class="keyword">static</font> <font class="keywordtype">void</font>
00059     terminate();
00060 
00061 
00062     <font class="comment">// Use these functions to determine if a value represents one of these</font>
00063     <font class="comment">// specia values.  On some platforms, regular C/C++ operators don't work</font>
00064     <font class="comment">// as we need them too, so we have these helper functions.</font>
00065 
00072     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00073     isNaN(<font class="keywordtype">double</font>    theNumber)<font class="keyword"></font>
00074 <font class="keyword">    </font>{
00075         <font class="keywordflow">return</font> s_NaN == theNumber;
00076     }
00077 
00084     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00085     isPositiveInfinity(<font class="keywordtype">double</font>   theNumber)<font class="keyword"></font>
00086 <font class="keyword">    </font>{
00087         <font class="keywordflow">return</font> s_positiveInfinity == theNumber;
00088     }
00089 
00096     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00097     isNegativeInfinity(<font class="keywordtype">double</font>   theNumber)<font class="keyword"></font>
00098 <font class="keyword">    </font>{
00099         <font class="keywordflow">return</font> s_negativeInfinity == theNumber;
00100     }
00101 
00108     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00109     isPositiveZero(<font class="keywordtype">double</font>   theNumber)<font class="keyword"></font>
00110 <font class="keyword">    </font>{
00111         <font class="keywordflow">return</font> s_positiveZero == theNumber;
00112     }
00113 
00120     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00121     isNegativeZero(<font class="keywordtype">double</font>   theNumber)<font class="keyword"></font>
00122 <font class="keyword">    </font>{
00123         <font class="keywordflow">return</font> s_negativeZero == theNumber;
00124     }
00125 
00126     <font class="comment">// These can be used to initialize values, but should not</font>
00127     <font class="comment">// be used to do equality comparisons, as == may fail on</font>
00128     <font class="comment">// some platforms.</font>
00129     <font class="comment">//</font>
00130 
00136     <font class="keyword">static</font> <font class="keywordtype">double</font>
00137     getNaN()<font class="keyword"></font>
00138 <font class="keyword">    </font>{
00139         <font class="keywordflow">return</font> s_NaN.d;
00140     }
00141 
00147     <font class="keyword">static</font> <font class="keywordtype">double</font>
00148     getPositiveInfinity()<font class="keyword"></font>
00149 <font class="keyword">    </font>{
00150         <font class="keywordflow">return</font> s_positiveInfinity.d;
00151     }
00152 
00158     <font class="keyword">static</font> <font class="keywordtype">double</font>
00159     getNegativeInfinity()<font class="keyword"></font>
00160 <font class="keyword">    </font>{
00161         <font class="keywordflow">return</font> s_negativeInfinity.d;
00162     }
00163 
00172     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00173     equal(
00174             <font class="keywordtype">double</font>  theLHS,
00175             <font class="keywordtype">double</font>  theRHS);
00176 
00185     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00186     notEqual(
00187             <font class="keywordtype">double</font>  theLHS,
00188             <font class="keywordtype">double</font>  theRHS)<font class="keyword"></font>
00189 <font class="keyword">    </font>{
00190         <font class="keywordflow">return</font> !equal(theLHS, theRHS);
00191     }
00192 
00201     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00202     lessThan(
00203             <font class="keywordtype">double</font>  theLHS,
00204             <font class="keywordtype">double</font>  theRHS);
00205 
00214     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00215     lessThanOrEqual(
00216             <font class="keywordtype">double</font>  theLHS,
00217             <font class="keywordtype">double</font>  theRHS);
00218 
00227     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00228     greaterThan(
00229             <font class="keywordtype">double</font>  theLHS,
00230             <font class="keywordtype">double</font>  theRHS);
00231 
00240     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00241     greaterThanOrEqual(
00242             <font class="keywordtype">double</font>  theLHS,
00243             <font class="keywordtype">double</font>  theRHS);
00244 
00253     <font class="keyword">static</font> <font class="keywordtype">double</font>
00254     <a class="code" href="XalanDOMString_8hpp.html#a13">add</a>(
00255             <font class="keywordtype">double</font>  theLHS,
00256             <font class="keywordtype">double</font>  theRHS);
00257 
00266     <font class="keyword">static</font> <font class="keywordtype">double</font>
00267     subtract(
00268             <font class="keywordtype">double</font>  theLHS,
00269             <font class="keywordtype">double</font>  theRHS);
00270 
00279     <font class="keyword">static</font> <font class="keywordtype">double</font>
00280     multiply(
00281             <font class="keywordtype">double</font>  theLHS,
00282             <font class="keywordtype">double</font>  theRHS);
00283 
00292     <font class="keyword">static</font> <font class="keywordtype">double</font>
00293     divide(
00294             <font class="keywordtype">double</font>  theLHS,
00295             <font class="keywordtype">double</font>  theRHS);
00296 
00306     <font class="keyword">static</font> <font class="keywordtype">double</font>
00307     modulus(
00308             <font class="keywordtype">double</font>  theLHS,
00309             <font class="keywordtype">double</font>  theRHS);
00310 
00319     <font class="keyword">static</font> <font class="keywordtype">double</font>
00320     negative(<font class="keywordtype">double</font> theDouble);
00321 
00329     <font class="keyword">static</font> <font class="keywordtype">double</font>
00330     abs(<font class="keywordtype">double</font> theDouble);
00331 
00332     <font class="comment">// Some functors to do the same thing.  This is for</font>
00333     <font class="comment">// STL integration...</font>
00334 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00335 <font class="preprocessor"></font>    <font class="keyword">struct </font>equalFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00336     #else
00337     struct equalFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00338     #endif
00339     {
00340         result_type
00341         operator()(
00342             first_argument_type     theLHS,
00343             second_argument_type    theRHS)<font class="keyword"> const</font>
00344 <font class="keyword">        </font>{
00345             <font class="keywordflow">return</font> equal(theLHS, theRHS);
00346         }
00347     };
00348 
00349 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00350 <font class="preprocessor"></font>    <font class="keyword">struct </font>notEqualFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00351     #else
00352     struct notEqualFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00353     #endif
00354     {
00355         result_type
00356         operator()(
00357             first_argument_type     theLHS,
00358             second_argument_type    theRHS)<font class="keyword"> const</font>
00359 <font class="keyword">        </font>{
00360             <font class="keywordflow">return</font> notEqual(theLHS, theRHS);
00361         }
00362     };
00363 
00364 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00365 <font class="preprocessor"></font>    <font class="keyword">struct </font>lessThanFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00366     #else
00367     struct lessThanFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00368     #endif
00369     {
00370         result_type
00371         operator()(
00372             first_argument_type     theLHS,
00373             second_argument_type    theRHS)<font class="keyword"> const</font>
00374 <font class="keyword">        </font>{
00375             <font class="keywordflow">return</font> lessThan(theLHS, theRHS);
00376         }
00377     };
00378 
00379 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00380 <font class="preprocessor"></font>    <font class="keyword">struct </font>lessThanOrEqualFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00381     #else
00382     struct lessThanOrEqualFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00383     #endif
00384     {
00385         result_type
00386         operator()(
00387             first_argument_type     theLHS,
00388             second_argument_type    theRHS)<font class="keyword"> const</font>
00389 <font class="keyword">        </font>{
00390             <font class="keywordflow">return</font> lessThanOrEqual(theLHS, theRHS);
00391         }
00392     };
00393 
00394 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00395 <font class="preprocessor"></font>    <font class="keyword">struct </font>greaterThanFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00396     #else
00397     struct greaterThanFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00398     #endif
00399     {
00400         result_type
00401         operator()(
00402             first_argument_type     theLHS,
00403             second_argument_type    theRHS)<font class="keyword"> const</font>
00404 <font class="keyword">        </font>{
00405             <font class="keywordflow">return</font> greaterThan(theLHS, theRHS);
00406         }
00407     };
00408 
00409 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00410 <font class="preprocessor"></font>    <font class="keyword">struct </font>greaterThanOrEqualFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00411     #else
00412     struct greaterThanOrEqualFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, bool&gt;
00413     #endif
00414     {
00415         result_type
00416         operator()(
00417             first_argument_type     theLHS,
00418             second_argument_type    theRHS)<font class="keyword"> const</font>
00419 <font class="keyword">        </font>{
00420             <font class="keywordflow">return</font> greaterThanOrEqual(theLHS, theRHS);
00421         }
00422     };
00423 
00424 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00425 <font class="preprocessor"></font>    <font class="keyword">struct </font>addFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, double&gt;
00426     #else
00427     struct addFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, double&gt;
00428     #endif
00429     {
00430         result_type
00431         operator()(
00432             first_argument_type     theLHS,
00433             second_argument_type    theRHS)<font class="keyword"> const</font>
00434 <font class="keyword">        </font>{
00435             <font class="keywordflow">return</font> <a class="code" href="XalanDOMString_8hpp.html#a13">add</a>(theLHS, theRHS);
00436         }
00437     };
00438 
00439 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00440 <font class="preprocessor"></font>    <font class="keyword">struct </font>subtractFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, double&gt;
00441     #else
00442     struct subtractFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, double&gt;
00443     #endif
00444     {
00445         result_type
00446         operator()(
00447             first_argument_type     theLHS,
00448             second_argument_type    theRHS)<font class="keyword"> const</font>
00449 <font class="keyword">        </font>{
00450             <font class="keywordflow">return</font> subtract(theLHS, theRHS);
00451         }
00452     };
00453 
00454 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00455 <font class="preprocessor"></font>    <font class="keyword">struct </font>multiplyFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, double&gt;
00456     #else
00457     struct multiplyFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, double&gt;
00458     #endif
00459     {
00460         result_type
00461         operator()(
00462             first_argument_type     theLHS,
00463             second_argument_type    theRHS)<font class="keyword"> const</font>
00464 <font class="keyword">        </font>{
00465             <font class="keywordflow">return</font> multiply(theLHS, theRHS);
00466         }
00467     };
00468 
00469 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00470 <font class="preprocessor"></font>    <font class="keyword">struct </font>divideFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, double&gt;
00471     #else
00472     struct divideFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, double&gt;
00473     #endif
00474     {
00475         result_type
00476         operator()(
00477             first_argument_type     theLHS,
00478             second_argument_type    theRHS)<font class="keyword"> const</font>
00479 <font class="keyword">        </font>{
00480             <font class="keywordflow">return</font> divide(theLHS, theRHS);
00481         }
00482     };
00483 
00484 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00485 <font class="preprocessor"></font>    <font class="keyword">struct </font>modulusFunction : <font class="keyword">public</font> binary_function&lt;const double&amp;, const double&amp;, double&gt;
00486     #else
00487     struct modulusFunction : <font class="keyword">public</font> std::binary_function&lt;const double&amp;, const double&amp;, double&gt;
00488     #endif
00489     {
00490         result_type
00491         operator()(
00492             first_argument_type     theLHS,
00493             second_argument_type    theRHS)<font class="keyword"> const</font>
00494 <font class="keyword">        </font>{
00495             <font class="keywordflow">return</font> modulus(theLHS, theRHS);
00496         }
00497     };
00498 
00499 <font class="preprocessor">    #if defined(XALAN_NO_STD_NAMESPACE)</font>
00500 <font class="preprocessor"></font>    <font class="keyword">struct </font>negativeFunction : <font class="keyword">public</font> unary_function&lt;const double&amp;, double&gt;
00501     #else
00502     struct negativeFunction : <font class="keyword">public</font> std::unary_function&lt;const double&amp;, double&gt;
00503     #endif
00504     {
00505         result_type
00506         operator()(argument_type    theDouble)<font class="keyword"> const</font>
00507 <font class="keyword">        </font>{
00508             <font class="keywordflow">return</font> negative(theDouble);
00509         }
00510     };
00511 
00519     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00520     isValid(<font class="keyword">const</font> <a class="code" href="classXalanDOMString.html">XalanDOMString</a>&amp;   theString);
00521 
00529     <font class="keyword">static</font> <font class="keywordtype">bool</font>
00530     isValid(<font class="keyword">const</font> XalanDOMChar*     theString);
00531 
00541     <font class="keyword">static</font> <font class="keywordtype">double</font>
00542     toDouble(
00543             <font class="keyword">const</font> <a class="code" href="classXalanDOMString.html">XalanDOMString</a>&amp;   theString,
00544             MemoryManager&amp;          theManager);
00545 
00555     <font class="keyword">static</font> <font class="keywordtype">double</font>
00556     toDouble(
00557             <font class="keyword">const</font> XalanDOMChar*     theString,
00558             MemoryManager&amp;          theManager);
00559 
00567     <font class="keyword">static</font> <font class="keywordtype">double</font>
00568     round(<font class="keywordtype">double</font>    theValue);
00569 
00577     <font class="keyword">static</font> <font class="keywordtype">double</font>
00578     ceiling(<font class="keywordtype">double</font>  theValue)<font class="keyword"></font>
00579 <font class="keyword">    </font>{
00580 <font class="preprocessor">#if defined(XALAN_STRICT_ANSI_HEADERS)</font>
00581 <font class="preprocessor"></font>        <font class="keywordflow">return</font> std::ceil(theValue);
00582 <font class="preprocessor">#else</font>
00583 <font class="preprocessor"></font>        <font class="keywordflow">return</font> ceil(theValue);
00584 <font class="preprocessor">#endif</font>
00585 <font class="preprocessor"></font>    }
00586 
00594     <font class="keyword">static</font> <font class="keywordtype">double</font>
00595     floor(<font class="keywordtype">double</font>    theValue)<font class="keyword"></font>
00596 <font class="keyword">    </font>{
00597 <font class="preprocessor">#if defined(XALAN_STRICT_ANSI_HEADERS)</font>
00598 <font class="preprocessor"></font>        <font class="keywordflow">return</font> std::floor(theValue);
00599 <font class="preprocessor">#else</font>
00600 <font class="preprocessor"></font>        return ::floor(theValue);
00601 <font class="preprocessor">#endif</font>
00602 <font class="preprocessor"></font>    }
00603 
00604     <font class="keyword">typedef</font> <font class="keyword">union</font>
00605     {
00606         <font class="keywordtype">double</font>  d;
00607         <font class="keyword">struct</font>
00608         {
00609             <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>    dw1;
00610             <font class="keywordtype">unsigned</font> <font class="keywordtype">int</font>    dw2;
00611         } dwords;
00612 
00613         <font class="keywordtype">bool</font>
00614         <a class="code" href="ElemAttributeSet_8hpp.html#a1">operator==</a>(<font class="keywordtype">double</font>   theNumber)<font class="keyword"> const</font>
00615 <font class="keyword">        </font>{
00616             <font class="keyword">const</font> NumberUnion   temp = { theNumber };
00617 
00618             <font class="keywordflow">return</font> dwords.dw1 == temp.dwords.dw1 &amp;&amp;
00619                    dwords.dw2 == temp.dwords.dw2;
00620         }
00621 
00622     } NumberUnion;
00623 
00624 <font class="keyword">private</font>:
00625 
00626 <font class="preprocessor">#if defined(XALAN_NO_STD_NUMERIC_LIMITS)</font>
00627 <font class="preprocessor"></font>    <font class="keyword">static</font> NumberUnion          s_NaN;
00628 <font class="preprocessor">#else</font>
00629 <font class="preprocessor"></font>    <font class="keyword">static</font> <font class="keyword">const</font> NumberUnion    s_NaN;
00630 <font class="preprocessor">#endif</font>
00631 <font class="preprocessor"></font>
00632     <font class="keyword">static</font> <font class="keyword">const</font> NumberUnion    s_positiveInfinity;
00633     <font class="keyword">static</font> <font class="keyword">const</font> NumberUnion    s_negativeInfinity;
00634     <font class="keyword">static</font> <font class="keyword">const</font> NumberUnion    s_positiveZero;
00635     <font class="keyword">static</font> <font class="keyword">const</font> NumberUnion    s_negativeZero;
00636 };
00637 
00638 
00639 
00640 XALAN_CPP_NAMESPACE_END
00641 
00642 
00643 
00644 <font class="preprocessor">#endif  // DOUBLESUPPORT_HEADER_GUARD_1357924680</font>
</font></pre></div><p align="center"><a href="diagramnotes.html">Interpreting class diagrams</a></p>
<p><FONT color="#000000" face="arial,helvetica,sanserif" size="-1">
<i><A href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</A> and 
<A href="http://www.research.att.com/sw/tools/graphviz/">GraphViz</A> are used to generate this API documentation from the Xalan-C header files.</I></FONT></p>

<TABLE border="0" cellpadding="0" cellspacing="0" width="820"><TR><TD bgcolor="#0086b2"><IMG height="1" src="../resources/dot.gif" width="1" alt="dot"></TD></TR></TABLE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="80%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xalan-C++ XSLT Processor Version 1.10</B><BR>
			Copyright &copy; 1999-2004 The Apache Software Foundation. All Rights Reserved.</i></p>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0" ALT="Apache Logo">
		</TD>
	</TR>
</TABLE>
