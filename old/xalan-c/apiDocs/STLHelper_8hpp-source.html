<HTML><HEAD><TITLE>Xalan-C++ API Documentation</TITLE></HEAD>
<BODY>
<h2 align="center">Xalan-C++ API Documentation</h2>
<h3 align="center">The Xalan C++ XSLT Processor Version 1.10</h3>
</BODY>
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>STLHelper.hpp</h1><a href="STLHelper_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> * Copyright 1999-2004 The Apache Software Foundation.</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</font>
00005 <font class="comment"> * you may not use this file except in compliance with the License.</font>
00006 <font class="comment"> * You may obtain a copy of the License at</font>
00007 <font class="comment"> *</font>
00008 <font class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</font>
00009 <font class="comment"> *</font>
00010 <font class="comment"> * Unless required by applicable law or agreed to in writing, software</font>
00011 <font class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</font>
00012 <font class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</font>
00013 <font class="comment"> * See the License for the specific language governing permissions and</font>
00014 <font class="comment"> * limitations under the License.</font>
00015 <font class="comment"> */</font>
00016 <font class="preprocessor">#if !defined(STLHELPERS_HEADER_GUARD_1357924680)</font>
<a name="l00017"></a><a class="code" href="STLHelper_8hpp.html#a0">00017</a> <font class="preprocessor"></font><font class="preprocessor">#define STLHELPERS_HEADER_GUARD_1357924680</font>
00018 <font class="preprocessor"></font>
00019 
00020 
00021 <font class="comment">// Base include file.  Must be first.</font>
00022 <font class="preprocessor">#include &lt;<a class="code" href="PlatformDefinitions_8hpp.html">xalanc/Include/PlatformDefinitions.hpp</a>&gt;</font>
00023 
00024 
00025 
00026 <font class="preprocessor">#include &lt;algorithm&gt;</font>
00027 <font class="preprocessor">#include &lt;functional&gt;</font>
00028 
00029 
00030 
00031 <font class="preprocessor">#include &lt;<a class="code" href="XalanMap_8hpp.html">xalanc/Include/XalanMap.hpp</a>&gt;</font>
00032 
00033 
00034 
00035 XALAN_CPP_NAMESPACE_BEGIN
00036 
00037 
00038 
00039 template&lt;class Type&gt;
<a name="l00040"></a><a class="code" href="structXalanDestroyFunctor.html">00040</a> <font class="keyword">struct</font>
00041 <a class="code" href="structXalanDestroyFunctor.html">XalanDestroyFunctor</a>
00042 {
00043     <font class="keywordtype">void</font>
<a name="l00044"></a><a class="code" href="structXalanDestroyFunctor.html#a0">00044</a>     operator()(Type&amp;  theArg)<font class="keyword"></font>
00045 <font class="keyword">    </font>{
00046         theArg.~Type();
00047     }
00048 
00049     <font class="keywordtype">void</font>
<a name="l00050"></a><a class="code" href="structXalanDestroyFunctor.html#a1">00050</a>     operator()(Type*  theArg)<font class="keyword"></font>
00051 <font class="keyword">    </font>{
00052         theArg-&gt;~Type();
00053     }
00054 
00055     <font class="keywordtype">void</font>
<a name="l00056"></a><a class="code" href="structXalanDestroyFunctor.html#a2">00056</a>     operator()(<font class="keyword">const</font> Type*    theArg)<font class="keyword"></font>
00057 <font class="keyword">    </font>{
00058         (*this)(const_cast&lt;Type*&gt;(theArg));
00059     }
00060 
00061     <font class="keywordtype">void</font>
<a name="l00062"></a><a class="code" href="structXalanDestroyFunctor.html#a3">00062</a>     operator()(
00063                 Type*               theArg,
00064                 MemoryManagerType&amp;  theMemoryManager)<font class="keyword"></font>
00065 <font class="keyword">    </font>{
00066         <font class="keywordflow">if</font> (theArg != 0)
00067         {
00068             (*this)(*theArg);
00069 
00070             theMemoryManager.deallocate(theArg);
00071         }
00072     }
00073 
00074     <font class="keywordtype">void</font>
<a name="l00075"></a><a class="code" href="structXalanDestroyFunctor.html#a4">00075</a>     operator()(
00076                 <font class="keyword">const</font> Type*         theArg,
00077                 MemoryManagerType&amp;  theMemoryManager)<font class="keyword"></font>
00078 <font class="keyword">    </font>{
00079         (*this)(const_cast&lt;Type*&gt;(theArg), theMemoryManager);
00080     }
00081 };
00082 
00083 
00084 
00085 template&lt;class Type&gt;
00086 <a class="code" href="structXalanDestroyFunctor.html">XalanDestroyFunctor&lt;Type&gt;</a>
<a name="l00087"></a><a class="code" href="STLHelper_8hpp.html#a1">00087</a> <a class="code" href="STLHelper_8hpp.html#a1">makeXalanDestroyFunctor</a>(<font class="keyword">const</font> Type*     <font class="comment">/* theType */</font>)<font class="keyword"></font>
00088 <font class="keyword"></font>{
00089     <font class="keywordflow">return</font> <a class="code" href="structXalanDestroyFunctor.html">XalanDestroyFunctor&lt;Type&gt;</a>();
00090 }
00091 
00092 
00093 
00097 template &lt;class Type&gt;
00098 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00099 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structDeleteFunctor.html">DeleteFunctor</a> : <font class="keyword">public</font> unary_function&lt;const Type*, void&gt;
00100 #else
<a name="l00101"></a><a class="code" href="structDeleteFunctor.html">00101</a> struct <a class="code" href="structDeleteFunctor.html">DeleteFunctor</a> : <font class="keyword">public</font> std::unary_function&lt;const Type*, void&gt;
00102 #endif
00103 {
00104 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00105 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;const Type*, void&gt;       <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00106 <font class="preprocessor">#else</font>
<a name="l00107"></a><a class="code" href="structDeleteFunctor.html#s0">00107</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;const Type*, void&gt;</a>  <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00108 <font class="preprocessor">#endif</font>
00109 <font class="preprocessor"></font>
<a name="l00110"></a><a class="code" href="structDeleteFunctor.html#s1">00110</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00111"></a><a class="code" href="structDeleteFunctor.html#s2">00111</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00112 
<a name="l00113"></a><a class="code" href="structDeleteFunctor.html#a0">00113</a>     <a class="code" href="structDeleteFunctor.html#a0">DeleteFunctor</a>(MemoryManagerType&amp;    theManager) :
00114         m_memoryManager(theManager)
00115     {
00116     }
00117 
00123     result_type
<a name="l00124"></a><a class="code" href="structDeleteFunctor.html#a1">00124</a>     <a class="code" href="structDeleteFunctor.html#a1">operator()</a>(argument_type    thePointer)<font class="keyword"> const</font>
00125 <font class="keyword">    </font>{
00126         <a class="code" href="STLHelper_8hpp.html#a1">makeXalanDestroyFunctor</a>(thePointer)(thePointer, m_memoryManager);
00127     }
00128 
00129 <font class="keyword">private</font>:
00130 
00131    MemoryManagerType&amp;   m_memoryManager;
00132 };
00133 
00134 
00135 
00136 <font class="preprocessor">#if !defined(XALAN_SGI_BASED_STL)</font>
00137 <font class="preprocessor"></font>
00142 template &lt;class PairType&gt;
00143 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00144 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structselect1st.html">select1st</a> : <font class="keyword">public</font> unary_function&lt;PairType, PairType::first_type&gt;
00145 #else
<a name="l00146"></a><a class="code" href="structselect1st.html">00146</a> struct <a class="code" href="structselect1st.html">select1st</a> : <font class="keyword">public</font> std::unary_function&lt;PairType, typename PairType::first_type&gt;
00147 #endif
00148 {
00149 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00150 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;PairType, PairType::first_type&gt;  <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00151 <font class="preprocessor">#else</font>
<a name="l00152"></a><a class="code" href="structselect1st.html#s0">00152</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;PairType, typename PairType::first_type&gt;</a>    <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00153 <font class="preprocessor">#endif</font>
00154 <font class="preprocessor"></font>
<a name="l00155"></a><a class="code" href="structselect1st.html#s1">00155</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00156"></a><a class="code" href="structselect1st.html#s2">00156</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00157 
<a name="l00158"></a><a class="code" href="structselect1st.html#s3">00158</a>     <font class="keyword">typedef</font> PairType                                value_type;
00159 
00166     result_type
<a name="l00167"></a><a class="code" href="structselect1st.html#a0">00167</a>     <a class="code" href="structDeleteFunctor.html#a1">operator()</a>(<font class="keyword">const</font> argument_type&amp;     thePair)<font class="keyword"> const</font>
00168 <font class="keyword">    </font>{
00169         <font class="keywordflow">return</font> thePair.first;
00170     }
00171 };
00172 
00173 
00174 
00179 template &lt;class PairType&gt;
00180 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00181 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structselect2nd.html">select2nd</a> : <font class="keyword">public</font> unary_function&lt;PairType, PairType::second_type&gt;
00182 #else
<a name="l00183"></a><a class="code" href="structselect2nd.html">00183</a> struct <a class="code" href="structselect2nd.html">select2nd</a> : <font class="keyword">public</font> std::unary_function&lt;PairType, typename PairType::second_type&gt;
00184 #endif
00185 {
00186 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00187 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;PairType, PairType::second_type&gt; <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00188 <font class="preprocessor">#else</font>
<a name="l00189"></a><a class="code" href="structselect2nd.html#s0">00189</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;PairType, typename PairType::second_type&gt;</a>   <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00190 <font class="preprocessor">#endif</font>
00191 <font class="preprocessor"></font>
<a name="l00192"></a><a class="code" href="structselect2nd.html#s1">00192</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00193"></a><a class="code" href="structselect2nd.html#s2">00193</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00194 
<a name="l00195"></a><a class="code" href="structselect2nd.html#s3">00195</a>     <font class="keyword">typedef</font> PairType                                value_type;
00196 
00203     result_type
<a name="l00204"></a><a class="code" href="structselect2nd.html#a0">00204</a>     <a class="code" href="structDeleteFunctor.html#a1">operator()</a>(<font class="keyword">const</font> argument_type&amp;     thePair)<font class="keyword"> const</font>
00205 <font class="keyword">    </font>{
00206         <font class="keywordflow">return</font> thePair.second;
00207     }
00208 };
00209 
00210 <font class="preprocessor">#endif</font>
00211 <font class="preprocessor"></font>
00212 
00213 
00217 template &lt;class Type&gt;
00218 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00219 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structClearFunctor.html">ClearFunctor</a> : <font class="keyword">public</font> unary_function&lt;Type, void&gt;
00220 #else
<a name="l00221"></a><a class="code" href="structClearFunctor.html">00221</a> struct <a class="code" href="structClearFunctor.html">ClearFunctor</a> : <font class="keyword">public</font> std::unary_function&lt;Type, void&gt;
00222 #endif
00223 {
00224 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00225 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;Type, void&gt;      <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00226 <font class="preprocessor">#else</font>
<a name="l00227"></a><a class="code" href="structClearFunctor.html#s0">00227</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;Type, void&gt;</a> <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00228 <font class="preprocessor">#endif</font>
00229 <font class="preprocessor"></font>
<a name="l00230"></a><a class="code" href="structClearFunctor.html#s1">00230</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00231"></a><a class="code" href="structClearFunctor.html#s2">00231</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00232 
<a name="l00233"></a><a class="code" href="structClearFunctor.html#s3">00233</a>     <font class="keyword">typedef</font> Type                                    value_type;
00234 
00241     result_type
<a name="l00242"></a><a class="code" href="structClearFunctor.html#a0">00242</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(argument_type&amp;   theArg)<font class="keyword"> const</font>
00243 <font class="keyword">    </font>{
00244         theArg.clear();
00245     }
00246 };
00247 
00248 
00249 
00253 template &lt;class T&gt;
00254 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00255 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structMapValueDeleteFunctor.html">MapValueDeleteFunctor</a> : <font class="keyword">public</font> unary_function&lt;const typename T::value_type&amp;, void&gt;
00256 #else
<a name="l00257"></a><a class="code" href="structMapValueDeleteFunctor.html">00257</a> struct <a class="code" href="structMapValueDeleteFunctor.html">MapValueDeleteFunctor</a> : <font class="keyword">public</font> std::unary_function&lt;const typename T::value_type&amp;, void&gt;
00258 #endif
00259 {
00260 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00261 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;const typename T::value_type&amp;, void&gt;         <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00262 <font class="preprocessor">#else</font>
<a name="l00263"></a><a class="code" href="structMapValueDeleteFunctor.html#s0">00263</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;const typename T::value_type&amp;, void&gt;</a>    <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00264 <font class="preprocessor">#endif</font>
00265 <font class="preprocessor"></font>
<a name="l00266"></a><a class="code" href="structMapValueDeleteFunctor.html#s1">00266</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00267"></a><a class="code" href="structMapValueDeleteFunctor.html#s2">00267</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00268 
<a name="l00269"></a><a class="code" href="structMapValueDeleteFunctor.html#a0">00269</a>     <a class="code" href="structMapValueDeleteFunctor.html#a0">MapValueDeleteFunctor</a>(MemoryManagerType&amp;    theManager) :
00270         m_memoryManager(theManager)
00271     {
00272     }
00273 
00280     result_type
<a name="l00281"></a><a class="code" href="structMapValueDeleteFunctor.html#a1">00281</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(argument_type    thePair)<font class="keyword"> const</font>
00282 <font class="keyword">    </font>{
00283         <a class="code" href="STLHelper_8hpp.html#a1">makeXalanDestroyFunctor</a>(thePair.second)(thePair.second, m_memoryManager);
00284     }
00285 
00286 <font class="keyword">private</font>:
00287 
00288     MemoryManagerType&amp;  m_memoryManager;
00289 };
00290 
00291 
00292 
00293 template&lt;class MapType&gt;
00294 <a class="code" href="structMapValueDeleteFunctor.html">MapValueDeleteFunctor&lt;MapType&gt;</a>
<a name="l00295"></a><a class="code" href="STLHelper_8hpp.html#a2">00295</a> <a class="code" href="STLHelper_8hpp.html#a2">makeMapValueDeleteFunctor</a>(MapType&amp;   theMap)<font class="keyword"></font>
00296 <font class="keyword"></font>{
00297     <font class="keywordflow">return</font> <a class="code" href="structMapValueDeleteFunctor.html">MapValueDeleteFunctor&lt;MapType&gt;</a>(theMap.getMemoryManager());
00298 }
00299 
00300 
00301 
00311 template&lt;class T&gt;
00312 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00313 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structless__null__terminated__arrays.html">less_null_terminated_arrays</a> : <font class="keyword">public</font> binary_function&lt;const T*, const T*, bool&gt;
00314 #else
<a name="l00315"></a><a class="code" href="structless__null__terminated__arrays.html">00315</a> struct <a class="code" href="structless__null__terminated__arrays.html">less_null_terminated_arrays</a> : <font class="keyword">public</font> std::binary_function&lt;const T*, const T*, bool&gt;
00316 #endif
00317 {
00318 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00319 <font class="preprocessor"></font>    <font class="keyword">typedef</font> binary_function&lt;const T*, const T*, bool&gt;           <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00320 <font class="preprocessor">#else</font>
<a name="l00321"></a><a class="code" href="structless__null__terminated__arrays.html#s0">00321</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1binary__function.html">std::binary_function&lt;const T*, const T*, bool&gt;</a>      <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00322 <font class="preprocessor">#endif</font>
00323 <font class="preprocessor"></font>
<a name="l00324"></a><a class="code" href="structless__null__terminated__arrays.html#s1">00324</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00325"></a><a class="code" href="structless__null__terminated__arrays.html#s2">00325</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::first_argument_type     first_argument_type;
<a name="l00326"></a><a class="code" href="structless__null__terminated__arrays.html#s3">00326</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::second_argument_type    second_argument_type;
00327 
00336     result_type
<a name="l00337"></a><a class="code" href="structless__null__terminated__arrays.html#a0">00337</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00338             first_argument_type     theLHS,
00339             second_argument_type    theRHS)<font class="keyword"> const</font>
00340 <font class="keyword">    </font>{
00341         <font class="keywordflow">while</font>(*theLHS &amp;&amp; *theRHS)
00342         {
00343             <font class="keywordflow">if</font> (*theLHS != *theRHS)
00344             {
00345                 <font class="keywordflow">break</font>;
00346             }
00347             <font class="keywordflow">else</font>
00348             {
00349                 theLHS++;
00350                 theRHS++;
00351             }
00352         }
00353 
00354         <font class="keywordflow">return</font> *theLHS &lt; *theRHS ? <font class="keyword">true</font> : <font class="keyword">false</font>;
00355     }
00356 };
00357 
00358 
00359 
00360 template&lt;class T&gt;
<a name="l00361"></a><a class="code" href="structequal__null__terminated__arrays.html">00361</a> <font class="keyword">struct </font><a class="code" href="structequal__null__terminated__arrays.html">equal_null_terminated_arrays</a> : <font class="keyword">public</font> XALAN_STD_QUALIFIER binary_function&lt;const T*, const T*, bool&gt;
00362 {
<a name="l00363"></a><a class="code" href="structequal__null__terminated__arrays.html#s0">00363</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER binary_function&lt;const T*, const T*, bool&gt;       <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00364 
<a name="l00365"></a><a class="code" href="structequal__null__terminated__arrays.html#s1">00365</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00366"></a><a class="code" href="structequal__null__terminated__arrays.html#s2">00366</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::first_argument_type     first_argument_type;
<a name="l00367"></a><a class="code" href="structequal__null__terminated__arrays.html#s3">00367</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::second_argument_type    second_argument_type;
00376     result_type
<a name="l00377"></a><a class="code" href="structequal__null__terminated__arrays.html#a0">00377</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00378             first_argument_type     theLHS,
00379             second_argument_type    theRHS)<font class="keyword"> const</font>
00380 <font class="keyword">    </font>{
00381         <font class="keywordflow">while</font>(*theLHS &amp;&amp; *theRHS)
00382         {
00383             <font class="keywordflow">if</font> (*theLHS != *theRHS)
00384             {
00385                 <font class="keywordflow">return</font> <font class="keyword">false</font>;
00386             }
00387             <font class="keywordflow">else</font>
00388             {
00389                 ++theLHS;
00390                 ++theRHS;
00391             }
00392         }
00393 
00394         <font class="keywordflow">if</font> (*theLHS || *theRHS)
00395         {
00396             <font class="keywordflow">return</font> <font class="keyword">false</font>;
00397         }
00398         <font class="keywordflow">else</font>
00399         {
00400             <font class="keywordflow">return</font> <font class="keyword">true</font>;
00401         }
00402     }
00403 };
00404 
00405 
00406 
00407 template &lt;class T&gt;
<a name="l00408"></a><a class="code" href="structhash__null__terminated__arrays.html">00408</a> <font class="keyword">struct </font><a class="code" href="structhash__null__terminated__arrays.html">hash_null_terminated_arrays</a> : <font class="keyword">public</font> XALAN_STD_QUALIFIER unary_function&lt;const T*, size_t&gt;
00409 {
<a name="l00410"></a><a class="code" href="structhash__null__terminated__arrays.html#s0">00410</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER unary_function&lt;const T*, size_t&gt;        <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00411 
<a name="l00412"></a><a class="code" href="structhash__null__terminated__arrays.html#s1">00412</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00413"></a><a class="code" href="structhash__null__terminated__arrays.html#s2">00413</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type       argument_type;
00414 
00415     result_type
<a name="l00416"></a><a class="code" href="structhash__null__terminated__arrays.html#a0">00416</a>     <a class="code" href="structClearFunctor.html#a0">operator() </a>(argument_type   theKey)<font class="keyword"> const</font>
00417 <font class="keyword">    </font>{
00418         <font class="keyword">const</font> T*        theRawBuffer = theKey;
00419 
00420         result_type     theHashValue = 0; 
00421 
00422         <font class="keywordflow">while</font> (*theRawBuffer)
00423         {
00424             theHashValue = 5 * theHashValue + *theRawBuffer;
00425             ++theRawBuffer;
00426         }
00427 
00428         <font class="keywordflow">return</font> ++theHashValue;
00429     }
00430 };
00431 
00432 
00433 
00434 template&lt;&gt;
<a name="l00435"></a><a class="code" href="structXalanMapKeyTraits_3_01const_01XalanDOMChar_01_5_4.html">00435</a> <font class="keyword">struct </font><a class="code" href="structXalanMapKeyTraits.html">XalanMapKeyTraits</a>&lt;const XalanDOMChar*&gt;
00436 {
<a name="l00437"></a><a class="code" href="structXalanMapKeyTraits_3_01const_01XalanDOMChar_01_5_4.html#s0">00437</a>     <font class="keyword">typedef</font> <a class="code" href="structhash__null__terminated__arrays.html">hash_null_terminated_arrays&lt;XalanDOMChar&gt;</a>   <a class="code" href="structhash__null__terminated__arrays.html">Hasher</a>;
<a name="l00438"></a><a class="code" href="structXalanMapKeyTraits_3_01const_01XalanDOMChar_01_5_4.html#s1">00438</a>     <font class="keyword">typedef</font> <a class="code" href="structequal__null__terminated__arrays.html">equal_null_terminated_arrays&lt;XalanDOMChar&gt;</a>  <a class="code" href="structequal__null__terminated__arrays.html">Comparator</a>;
00439 };
00440 
00441 
00442 
00443 template&lt;class CollectionType&gt;
<a name="l00444"></a><a class="code" href="classCollectionClearGuard.html">00444</a> <font class="keyword">class </font><a class="code" href="classCollectionClearGuard.html">CollectionClearGuard</a>
00445 {
00446 <font class="keyword">public</font>:
00447 
<a name="l00448"></a><a class="code" href="classCollectionClearGuard.html#a0">00448</a>     <a class="code" href="classCollectionClearGuard.html#a0">CollectionClearGuard</a>(<a class="code" href="classXalanSet.html">CollectionType</a>&amp;    theCollection) :
00449         m_collection(&amp;theCollection)
00450     {
00451     }
00452 
<a name="l00453"></a><a class="code" href="classCollectionClearGuard.html#a1">00453</a>     <a class="code" href="classCollectionClearGuard.html#a1">~CollectionClearGuard</a>()<font class="keyword"></font>
00454 <font class="keyword">    </font>{
00455         <font class="keywordflow">if</font> (m_collection != 0)
00456         {
00457             m_collection-&gt;<a class="code" href="classXalanSet.html#a10">clear</a>();
00458         }
00459     }
00460 
00461     <font class="keywordtype">void</font>
<a name="l00462"></a><a class="code" href="classCollectionClearGuard.html#a2">00462</a>     <a class="code" href="classCollectionClearGuard.html#a2">release</a>()<font class="keyword"></font>
00463 <font class="keyword">    </font>{
00464         m_collection = 0;
00465     }
00466 
00467 <font class="keyword">private</font>:
00468 
00469     <font class="comment">// Not implemented...</font>
00470     <a class="code" href="classCollectionClearGuard.html#a0">CollectionClearGuard</a>(<font class="keyword">const</font> <a class="code" href="classCollectionClearGuard.html">CollectionClearGuard&lt;CollectionType&gt;</a>&amp;);
00471 
00472     <a class="code" href="classCollectionClearGuard.html">CollectionClearGuard&lt;CollectionType&gt;</a>&amp;
00473     operator=(<font class="keyword">const</font> <a class="code" href="classCollectionClearGuard.html">CollectionClearGuard&lt;CollectionType&gt;</a>&amp;);
00474 
00475     <font class="comment">// Data members...</font>
00476     <a class="code" href="classXalanSet.html">CollectionType</a>*     m_collection;
00477 };
00478 
00479 
00480 
00481 template&lt;class CollectionType, class DeleteFunctorType&gt;
<a name="l00482"></a><a class="code" href="classCollectionDeleteGuard.html">00482</a> <font class="keyword">class </font><a class="code" href="classCollectionDeleteGuard.html">CollectionDeleteGuard</a>
00483 {
00484 <font class="keyword">public</font>:
00485 
<a name="l00486"></a><a class="code" href="classCollectionDeleteGuard.html#a0">00486</a>     <a class="code" href="classCollectionDeleteGuard.html#a0">CollectionDeleteGuard</a>(<a class="code" href="classXalanSet.html">CollectionType</a>&amp;   theCollection) :
00487         m_collection(&amp;theCollection)
00488     {
00489     }
00490 
<a name="l00491"></a><a class="code" href="classCollectionDeleteGuard.html#a1">00491</a>     <a class="code" href="classCollectionDeleteGuard.html#a1">~CollectionDeleteGuard</a>()<font class="keyword"></font>
00492 <font class="keyword">    </font>{
00493         <font class="keywordflow">if</font> (m_collection != 0)
00494         {
00495 <font class="preprocessor">#if !defined(XALAN_NO_STD_NAMESPACE)</font>
00496 <font class="preprocessor"></font>            <font class="keyword">using</font> std::for_each;
00497 <font class="preprocessor">#endif</font>
00498 <font class="preprocessor"></font>
00499             <font class="comment">// Delete all of the objects in the temp vector.</font>
00500             for_each(m_collection-&gt;<a class="code" href="classXalanSet.html#a3">begin</a>(),
00501                      m_collection-&gt;<a class="code" href="classXalanSet.html#a4">end</a>(),
00502                      DeleteFunctorType(m_collection-&gt;<a class="code" href="classXalanSet.html#a2">getMemoryManager</a>()));
00503         }
00504     }
00505 
00506     <font class="keywordtype">void</font>
<a name="l00507"></a><a class="code" href="classCollectionDeleteGuard.html#a2">00507</a>     <a class="code" href="classCollectionDeleteGuard.html#a2">release</a>()<font class="keyword"></font>
00508 <font class="keyword">    </font>{
00509         m_collection = 0;
00510     }
00511 
00512 <font class="keyword">private</font>:
00513 
00514     <font class="comment">// Not implemented...</font>
00515     <a class="code" href="classCollectionDeleteGuard.html#a0">CollectionDeleteGuard</a>(<font class="keyword">const</font> <a class="code" href="classCollectionDeleteGuard.html">CollectionDeleteGuard&lt;CollectionType, DeleteFunctorType&gt;</a>&amp;);
00516 
00517     <a class="code" href="classCollectionDeleteGuard.html">CollectionDeleteGuard&lt;CollectionType, DeleteFunctorType&gt;</a>&amp;
00518     operator=(<font class="keyword">const</font> <a class="code" href="classCollectionDeleteGuard.html">CollectionDeleteGuard&lt;CollectionType, DeleteFunctorType&gt;</a>&amp;);
00519 
00520     <font class="comment">// Data members...</font>
00521     <a class="code" href="classXalanSet.html">CollectionType</a>*     m_collection;
00522 };
00523 
00524 
00525 
00526 template&lt;class T&gt;
00527 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00528 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structpointer__equals.html">pointer_equals</a> : <font class="keyword">public</font> binary_function&lt;const T*, const T*, bool&gt;
00529 #else
<a name="l00530"></a><a class="code" href="structpointer__equals.html">00530</a> struct <a class="code" href="structpointer__equals.html">pointer_equals</a> : <font class="keyword">public</font> std::binary_function&lt;const T*, const T*, bool&gt;
00531 #endif
00532 {
00533 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00534 <font class="preprocessor"></font>    <font class="keyword">typedef</font> binary_function&lt;const T*, const T*, bool&gt;           <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00535 <font class="preprocessor">#else</font>
<a name="l00536"></a><a class="code" href="structpointer__equals.html#s0">00536</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1binary__function.html">std::binary_function&lt;const T*, const T*, bool&gt;</a>      <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00537 <font class="preprocessor">#endif</font>
00538 <font class="preprocessor"></font>
<a name="l00539"></a><a class="code" href="structpointer__equals.html#s1">00539</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00540"></a><a class="code" href="structpointer__equals.html#s2">00540</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::first_argument_type     first_argument_type;
<a name="l00541"></a><a class="code" href="structpointer__equals.html#s3">00541</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::second_argument_type    second_argument_type;
00542 
00543     result_type
<a name="l00544"></a><a class="code" href="structpointer__equals.html#a0">00544</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00545         first_argument_type     theLHS,
00546         second_argument_type    theRHS)<font class="keyword"> const</font>
00547 <font class="keyword">    </font>{
00548         assert(theLHS != 0 &amp;&amp; theRHS != 0);
00549 
00550         <font class="keywordflow">return</font> *theLHS == *theRHS;
00551     }
00552 };
00553 
00554 
00555 
00556 template&lt;class T&gt;
00557 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00558 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structpointer__equals__predicate.html">pointer_equals_predicate</a> : <font class="keyword">public</font> unary_function&lt;const T*, bool&gt;
00559 #else
<a name="l00560"></a><a class="code" href="structpointer__equals__predicate.html">00560</a> struct <a class="code" href="structpointer__equals__predicate.html">pointer_equals_predicate</a> : <font class="keyword">public</font> std::unary_function&lt;const T*, bool&gt;
00561 #endif
00562 {
00563 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00564 <font class="preprocessor"></font>    <font class="keyword">typedef</font> unary_function&lt;const T*, bool&gt;          <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00565 <font class="preprocessor">#else</font>
<a name="l00566"></a><a class="code" href="structpointer__equals__predicate.html#s0">00566</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1unary__function.html">std::unary_function&lt;const T*, bool&gt;</a>     <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00567 <font class="preprocessor">#endif</font>
00568 <font class="preprocessor"></font>
<a name="l00569"></a><a class="code" href="structpointer__equals__predicate.html#s1">00569</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type     result_type;
<a name="l00570"></a><a class="code" href="structpointer__equals__predicate.html#s2">00570</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::argument_type   argument_type;
00571 
<a name="l00572"></a><a class="code" href="structpointer__equals__predicate.html#a0">00572</a>     <a class="code" href="structpointer__equals__predicate.html#a0">pointer_equals_predicate</a>(argument_type  theArg) :
00573         m_arg(theArg)
00574     {
00575     }
00576 
00577     result_type
<a name="l00578"></a><a class="code" href="structpointer__equals__predicate.html#a1">00578</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00579         argument_type   theOther)<font class="keyword"> const</font>
00580 <font class="keyword">    </font>{
00581         assert(theOther != 0);
00582 
00583         <font class="keywordflow">return</font> *theOther == *m_arg;
00584     }
00585 
00586 <font class="keyword">private</font>:
00587 
00588     <font class="keyword">const</font> argument_type     m_arg;
00589 };
00590 
00591 
00592 
00593 template&lt;class T&gt;
00594 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00595 <font class="preprocessor"></font><font class="keyword">struct </font><a class="code" href="structpointer__less.html">pointer_less</a> : <font class="keyword">public</font> binary_function&lt;const T*, const T*, bool&gt;
00596 #else
<a name="l00597"></a><a class="code" href="structpointer__less.html">00597</a> struct <a class="code" href="structpointer__less.html">pointer_less</a> : <font class="keyword">public</font> std::binary_function&lt;const T*, const T*, bool&gt;
00598 #endif
00599 {
00600 <font class="preprocessor">#if defined(XALAN_NO_STD_NAMESPACE)</font>
00601 <font class="preprocessor"></font>    <font class="keyword">typedef</font> binary_function&lt;const T*, const T*, bool&gt;           <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00602 <font class="preprocessor">#else</font>
<a name="l00603"></a><a class="code" href="structpointer__less.html#s0">00603</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> <a class="code" href="classstd_1_1binary__function.html">std::binary_function&lt;const T*, const T*, bool&gt;</a>      <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00604 <font class="preprocessor">#endif</font>
00605 <font class="preprocessor"></font>
<a name="l00606"></a><a class="code" href="structpointer__less.html#s1">00606</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00607"></a><a class="code" href="structpointer__less.html#s2">00607</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::first_argument_type     first_argument_type;
<a name="l00608"></a><a class="code" href="structpointer__less.html#s3">00608</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::second_argument_type    second_argument_type;
00609 
00610     result_type
<a name="l00611"></a><a class="code" href="structpointer__less.html#a0">00611</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00612         first_argument_type     theLHS,
00613         second_argument_type    theRHS)<font class="keyword"> const</font>
00614 <font class="keyword">    </font>{
00615         assert(theLHS != 0 &amp;&amp; theRHS != 0);
00616 
00617 <font class="preprocessor">#if !defined(XALAN_NO_STD_NAMESPACE)</font>
00618 <font class="preprocessor"></font>        <font class="keyword">using</font> std::less;
00619 <font class="preprocessor">#endif</font>
00620 <font class="preprocessor"></font>
00621         <font class="keywordflow">return</font> less&lt;T&gt;()(*theLHS, *theRHS);
00622     }
00623 };
00624 
00625 
00626 
00627 template&lt;class T&gt;
<a name="l00628"></a><a class="code" href="structpointer__equal.html">00628</a> <font class="keyword">struct </font><a class="code" href="structpointer__equal.html">pointer_equal</a> : <font class="keyword">public</font> XALAN_STD_QUALIFIER binary_function&lt;const T*, const T*, bool&gt;
00629 {
<a name="l00630"></a><a class="code" href="structpointer__equal.html#s0">00630</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER binary_function&lt;const T*, const T*, bool&gt; <a class="code" href="classstd_1_1unary__function.html">BaseClassType</a>;
00631 
<a name="l00632"></a><a class="code" href="structpointer__equal.html#s1">00632</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::result_type             result_type;
<a name="l00633"></a><a class="code" href="structpointer__equal.html#s2">00633</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::first_argument_type     first_argument_type;
<a name="l00634"></a><a class="code" href="structpointer__equal.html#s3">00634</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BaseClassType::second_argument_type    second_argument_type;
00635 
00636     result_type
<a name="l00637"></a><a class="code" href="structpointer__equal.html#a0">00637</a>     <a class="code" href="structClearFunctor.html#a0">operator()</a>(
00638         first_argument_type     theLHS,
00639         second_argument_type    theRHS)<font class="keyword"> const</font>
00640 <font class="keyword">    </font>{
00641         assert(theLHS != 0 &amp;&amp; theRHS != 0);
00642         <font class="keywordflow">return</font> XALAN_STD_QUALIFIER equal_to&lt;T&gt;()(*theLHS, *theRHS);
00643     }
00644 };
00645 
00646 
00647 
00648 
00649 XALAN_CPP_NAMESPACE_END
00650 
00651 
00652 
00653 <font class="preprocessor">#endif  // STLHELPERS_HEADER_GUARD_1357924680</font>
</font></pre></div><p align="center"><a href="diagramnotes.html">Interpreting class diagrams</a></p>
<p><FONT color="#000000" face="arial,helvetica,sanserif" size="-1">
<i><A href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</A> and 
<A href="http://www.research.att.com/sw/tools/graphviz/">GraphViz</A> are used to generate this API documentation from the Xalan-C header files.</I></FONT></p>

<TABLE border="0" cellpadding="0" cellspacing="0" width="820"><TR><TD bgcolor="#0086b2"><IMG height="1" src="../resources/dot.gif" width="1" alt="dot"></TD></TR></TABLE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="80%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xalan-C++ XSLT Processor Version 1.10</B><BR>
			Copyright &copy; 1999-2004 The Apache Software Foundation. All Rights Reserved.</i></p>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0" ALT="Apache Logo">
		</TD>
	</TR>
</TABLE>
