<HTML><HEAD><TITLE>Xalan-C++ API Documentation</TITLE></HEAD>
<BODY>
<h2 align="center">Xalan-C++ API Documentation</h2>
<h3 align="center">The Xalan C++ XSLT Processor Version 1.10</h3>
</BODY>
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>XalanMemMgrAutoPtr.hpp</h1><a href="XalanMemMgrAutoPtr_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> * Copyright 1999-2004 The Apache Software Foundation.</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</font>
00005 <font class="comment"> * you may not use this file except in compliance with the License.</font>
00006 <font class="comment"> * You may obtain a copy of the License at</font>
00007 <font class="comment"> *</font>
00008 <font class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</font>
00009 <font class="comment"> *</font>
00010 <font class="comment"> * Unless required by applicable law or agreed to in writing, software</font>
00011 <font class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</font>
00012 <font class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</font>
00013 <font class="comment"> * See the License for the specific language governing permissions and</font>
00014 <font class="comment"> * limitations under the License.</font>
00015 <font class="comment"> */</font>
00016 <font class="preprocessor">#if !defined(XALANMEMMGRAUTOPTR_HEADER_GUARD_1357924680)</font>
<a name="l00017"></a><a class="code" href="XalanMemMgrAutoPtr_8hpp.html#a0">00017</a> <font class="preprocessor"></font><font class="preprocessor">#define XALANMEMMGRAUTOPTR_HEADER_GUARD_1357924680</font>
00018 <font class="preprocessor"></font>
00019 
00020 
00021 <font class="comment">// Base include file.  Must be first.</font>
00022 <font class="preprocessor">#include &lt;<a class="code" href="PlatformSupportDefinitions_8hpp.html">xalanc/PlatformSupport/PlatformSupportDefinitions.hpp</a>&gt;</font>
00023 
00024 
00025 
00026 <font class="preprocessor">#include &lt;<a class="code" href="XalanMemoryManagement_8hpp.html">xalanc/Include/XalanMemoryManagement.hpp</a>&gt;</font>
00027 
00028 <font class="preprocessor">#include &lt;cstddef&gt;</font>
00029 
00030 <font class="preprocessor">#include &lt;cassert&gt;</font>
00031 
00032 <font class="preprocessor">#include &lt;utility&gt;</font>
00033 
00034 
00035 
00036 XALAN_CPP_NAMESPACE_BEGIN
00037 
00038 
00039 
<a name="l00040"></a><a class="code" href="XalanMemMgrAutoPtr_8hpp.html#a1">00040</a> <a class="code" href="XSLTInputSource_8hpp.html#a3">XALAN_USING_XERCES</a>(MemoryManager)
00041 
00042 <font class="comment">// An auto_ptr-like class that supports the MemoryManager class.</font>
00043 <font class="keyword">template</font>&lt;
00044             <font class="keyword">class   </font>Type, 
00045             <font class="keywordtype">bool</font>    toCallDestructor = <font class="keyword">true</font>&gt;
00046 <font class="keyword">class </font>XalanMemMgrAutoPtr
00047 {
00048 <font class="keyword">public</font>:
00049 
00050     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER pair&lt;MemoryManager*, Type*&gt; AutoPtrPairType;
00051 
00052     <font class="keyword">class </font>MemMgrAutoPtrData : <font class="keyword">public</font> AutoPtrPairType
00053     {
00054     <font class="keyword">public</font>:
00055         MemMgrAutoPtrData():
00056             AutoPtrPairType(0,0)<font class="keyword"></font>
00057 <font class="keyword">        </font>{
00058         }
00059 
00060         MemMgrAutoPtrData(  
00061                 MemoryManager*  memoryManager,
00062                 Type*           dataPointer): 
00063             AutoPtrPairType(memoryManager, dataPointer)<font class="keyword"></font>
00064 <font class="keyword">        </font>{
00065             invariants();
00066         }
00067         
00068         <font class="keywordtype">bool</font>
00069         isInitilized()<font class="keyword">const</font>
00070         {
00071             <font class="keywordflow">return</font> this-&gt;first != 0 &amp;&amp; this-&gt;second != 0;
00072         }
00073 
00074         <font class="keywordtype">void</font>
00075         deallocate()<font class="keyword"></font>
00076 <font class="keyword">        </font>{
00077             invariants();
00078 
00079             <font class="keywordflow">if</font> ( isInitilized() )
00080             {       
00081                 <font class="keywordflow">if</font> ( toCallDestructor ) 
00082                 {
00083                     this-&gt;second-&gt;~Type();
00084                 }
00085 
00086                 this-&gt;first-&gt;deallocate(this-&gt;second);
00087             }
00088         }
00089 
00090         <font class="keywordtype">void</font> 
00091         reset(
00092                 MemoryManager*      memoryManager ,
00093                 Type*               dataPointer)<font class="keyword"></font>
00094 <font class="keyword">        </font>{   
00095             invariants();
00096 
00097             this-&gt;first = memoryManager;
00098 
00099             this-&gt;second = dataPointer;
00100 
00101             invariants();
00102         }
00103 
00104     <font class="keyword">private</font>:
00105 
00106         <font class="keywordtype">void</font>
00107         invariants()<font class="keyword"> const</font>
00108 <font class="keyword">        </font>{
00109             assert(
00110                 isInitilized() ||
00111                 (this-&gt;first == 0 &amp;&amp; this-&gt;second == 0));
00112         }
00113     };
00114 
00115 
00116     XalanMemMgrAutoPtr(
00117             MemoryManager&amp;  theManager, 
00118             Type*           ptr) : 
00119         m_pointerInfo(&amp;theManager, ptr)<font class="keyword"></font>
00120 <font class="keyword">    </font>{
00121     }
00122 
00123     XalanMemMgrAutoPtr() :
00124         m_pointerInfo()<font class="keyword"></font>
00125 <font class="keyword">    </font>{
00126     }
00127 
00128     XalanMemMgrAutoPtr(<font class="keyword">const</font> XalanMemMgrAutoPtr&lt;Type, toCallDestructor&gt;&amp;    theSource) :
00129         m_pointerInfo(((XalanMemMgrAutoPtr&lt;Type&gt;&amp;)theSource).release())
00130     {
00131     }
00132 
00133     XalanMemMgrAutoPtr&lt;Type,toCallDestructor&gt;&amp;
00134     operator=(XalanMemMgrAutoPtr&lt;Type,toCallDestructor&gt;&amp;    theRHS)<font class="keyword"></font>
00135 <font class="keyword">    </font>{       
00136         <font class="keywordflow">if</font> (<font class="keyword">this</font> != &amp;theRHS)
00137         {
00138             m_pointerInfo.deallocate();
00139 
00140             m_pointerInfo = theRHS.release();
00141         }
00142 
00143         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00144     }
00145 
00146     ~XalanMemMgrAutoPtr()<font class="keyword"></font>
00147 <font class="keyword">    </font>{
00148         m_pointerInfo.deallocate();
00149     }
00150 
00151     Type&amp;
00152     operator*()<font class="keyword"> const</font>
00153 <font class="keyword">    </font>{
00154         <font class="keywordflow">return</font> *m_pointerInfo.second;
00155     }
00156 
00157     Type*
00158     operator-&gt;()<font class="keyword"> const</font>
00159 <font class="keyword">    </font>{
00160         <font class="keywordflow">return</font> m_pointerInfo.second;
00161     }
00162 
00163     Type*
00164     get()<font class="keyword"> const</font>
00165 <font class="keyword">    </font>{
00166         <font class="keywordflow">return</font> m_pointerInfo.second;
00167     }
00168 
00169     MemoryManager*
00170     getMemoryManager()<font class="keyword"></font>
00171 <font class="keyword">    </font>{
00172         <font class="keywordflow">return</font> m_pointerInfo.first;
00173     }
00174 
00175     <font class="keyword">const</font> MemoryManager*
00176     getMemoryManager()<font class="keyword"> const</font>
00177 <font class="keyword">    </font>{
00178         <font class="keywordflow">return</font> m_pointerInfo.first;
00179     }
00180 
00181     MemMgrAutoPtrData
00182     release()<font class="keyword"></font>
00183 <font class="keyword">    </font>{       
00184         MemMgrAutoPtrData tmp = m_pointerInfo;
00185     
00186         m_pointerInfo.reset(0, 0); 
00187         
00188         <font class="keywordflow">return</font> MemMgrAutoPtrData(tmp);
00189     }
00190 
00191     Type*
00192     releasePtr()<font class="keyword"></font>
00193 <font class="keyword">    </font>{       
00194         MemMgrAutoPtrData tmp = release();
00195     
00196         <font class="keywordflow">return</font> tmp.second;
00197     }   
00198     
00199     <font class="keywordtype">void</font>
00200     reset(
00201             MemoryManager*  theManager = 0,
00202             Type*           thePointer = 0)<font class="keyword"></font>
00203 <font class="keyword">    </font>{       
00204         m_pointerInfo.deallocate();
00205 
00206         m_pointerInfo.reset(theManager, thePointer);
00207     }
00208 
00209 <font class="keyword">private</font>:
00210 
00211     <font class="comment">// data member</font>
00212     MemMgrAutoPtrData   m_pointerInfo;
00213 };
00214 
00215 
00216 
00217 
00218 template&lt;class Type&gt;
<a name="l00219"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html">00219</a> <font class="keyword">class </font><a class="code" href="classXalanMemMgrAutoPtrArray.html">XalanMemMgrAutoPtrArray</a>
00220 {
00221 <font class="keyword">public</font>:
00222 
00223 <font class="preprocessor">#if defined(XALAN_STRICT_ANSI_HEADERS)</font>
00224 <font class="preprocessor"></font>    <font class="keyword">typedef</font> std::size_t     size_type;
00225 <font class="preprocessor">#else</font>
<a name="l00226"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#s0">00226</a> <font class="preprocessor"></font>    <font class="keyword">typedef</font> size_t          size_type;
00227 <font class="preprocessor">#endif</font>
00228 <font class="preprocessor"></font>
<a name="l00229"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html">00229</a>     <font class="keyword">class </font>MemMgrAutoPtrArrayData 
00230     {
00231     <font class="keyword">public</font>:
00232 
<a name="l00233"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a0">00233</a>         <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a0">MemMgrAutoPtrArrayData</a>():
00234             m_memoryManager(0),
00235             m_dataArray(0),
00236             m_size(0)
00237         {
00238         }
00239 
<a name="l00240"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a1">00240</a>         <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a0">MemMgrAutoPtrArrayData</a>( 
00241                 MemoryManager*  memoryManager,
00242                 Type*           dataPointer,
00243                 size_type       size): 
00244             m_memoryManager(memoryManager),
00245             m_dataArray(dataPointer),
00246             m_size(size)
00247         {
00248             invariants();
00249         }
00250     
00251         <font class="keywordtype">bool</font>
<a name="l00252"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a2">00252</a>         <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a2">isInitilized</a>()<font class="keyword">const</font>
00253         {
00254             <font class="keywordflow">return</font> m_memoryManager != 0 &amp;&amp; m_dataArray != 0  &amp;&amp; m_size != 0;
00255         }
00256 
00257         <font class="keywordtype">void</font>
<a name="l00258"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a3">00258</a>         <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a3">deallocate</a>()<font class="keyword"></font>
00259 <font class="keyword">        </font>{
00260             invariants();
00261 
00262             <font class="keywordflow">if</font> ( <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a2">isInitilized</a>() )
00263             {           
00264                 assert ( m_dataArray != 0 );
00265 
00266                 <font class="keywordflow">for</font> ( size_type i = 0; i &lt; m_size ; ++i )
00267                 {
00268                     m_dataArray[i].~Type();
00269                 }
00270 
00271                 m_memoryManager-&gt;deallocate(m_dataArray);
00272             }
00273         }
00274 
00275         <font class="keywordtype">void</font> 
<a name="l00276"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a4">00276</a>         <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a4">reset</a>(  
00277                 MemoryManager*  theMemoryManager,
00278                 Type*           thePointer,
00279                 size_type       size)<font class="keyword"></font>
00280 <font class="keyword">        </font>{   
00281             invariants();
00282 
00283             m_memoryManager = theMemoryManager;
00284 
00285             m_dataArray = thePointer;
00286 
00287             m_size = size;
00288 
00289             invariants();
00290         }   
00291 
<a name="l00292"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#m0">00292</a>         MemoryManager*  m_memoryManager;
00293 
<a name="l00294"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#m1">00294</a>         Type*           m_dataArray;
00295 
<a name="l00296"></a><a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#m2">00296</a>         size_type       m_size;
00297 
00298     <font class="keyword">private</font>:
00299 
00300         <font class="keywordtype">void</font>
00301         invariants()<font class="keyword">const</font>
00302         {
00303             assert(
00304                 <a class="code" href="classXalanMemMgrAutoPtrArray_1_1MemMgrAutoPtrArrayData.html#a2">isInitilized</a>() ||
00305                 (m_memoryManager == 0 &amp;&amp; m_dataArray == 0 &amp;&amp; m_size == 0));
00306         }
00307     };
00308 
<a name="l00309"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a0">00309</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a1">XalanMemMgrAutoPtrArray</a>(
00310             MemoryManager&amp;  theManager, 
00311             Type*           ptr,
00312             size_type       size) : 
00313         m_pointerInfo(
00314             &amp;theManager,
00315             ptr,
00316             size)
00317     {
00318     }   
00319 
<a name="l00320"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a1">00320</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a1">XalanMemMgrAutoPtrArray</a>() :
00321         m_pointerInfo()
00322     {
00323     }
00324 
<a name="l00325"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a2">00325</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a1">XalanMemMgrAutoPtrArray</a>(<font class="keyword">const</font> <a class="code" href="classXalanMemMgrAutoPtrArray.html">XalanMemMgrAutoPtrArray&lt;Type&gt;</a>&amp;    theSource) :
00326         m_pointerInfo(((XalanMemMgrAutoPtr&lt;Type&gt;&amp;)theSource).release())
00327     {
00328     }
00329 
00330     <a class="code" href="classXalanMemMgrAutoPtrArray.html">XalanMemMgrAutoPtrArray&lt;Type&gt;</a>&amp;
<a name="l00331"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a3">00331</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a3">operator=</a>(<a class="code" href="classXalanMemMgrAutoPtrArray.html">XalanMemMgrAutoPtrArray&lt;Type&gt;</a>&amp;    theRHS)<font class="keyword"></font>
00332 <font class="keyword">    </font>{       
00333         <font class="keywordflow">if</font> (<font class="keyword">this</font> != &amp;theRHS)
00334         {
00335             m_pointerInfo.deallocate();
00336 
00337             m_pointerInfo = theRHS.<a class="code" href="classXalanMemMgrAutoPtrArray.html#a12">release</a>();
00338         }
00339 
00340         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00341     }
00342 
<a name="l00343"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a4">00343</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a4">~XalanMemMgrAutoPtrArray</a>()<font class="keyword"></font>
00344 <font class="keyword">    </font>{
00345         m_pointerInfo.deallocate();
00346     }
00347 
00348     Type&amp;
<a name="l00349"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a5">00349</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a5">operator*</a>()<font class="keyword"> const</font>
00350 <font class="keyword">    </font>{
00351         <font class="keywordflow">return</font> *m_pointerInfo.m_dataArray;
00352     }
00353 
00354     Type*
<a name="l00355"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a6">00355</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a6">operator-&gt;</a>()<font class="keyword"> const</font>
00356 <font class="keyword">    </font>{
00357         <font class="keywordflow">return</font> m_pointerInfo.m_dataArray;
00358     }
00359 
00360     Type*
<a name="l00361"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a7">00361</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a7">get</a>()<font class="keyword"> const</font>
00362 <font class="keyword">    </font>{
00363         <font class="keywordflow">return</font> m_pointerInfo.m_dataArray;
00364     }
00365 
00366     size_type
<a name="l00367"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a8">00367</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a8">getSize</a>()<font class="keyword">const</font>
00368     {
00369         <font class="keywordflow">return</font> m_pointerInfo.m_size;
00370     }
00371 
00372     MemoryManager*
<a name="l00373"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a9">00373</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a9">getMemoryManager</a>()<font class="keyword"></font>
00374 <font class="keyword">    </font>{
00375         <font class="keywordflow">return</font> m_pointerInfo.m_memoryManager;
00376     }
00377 
00378     <font class="keyword">const</font> MemoryManager*
<a name="l00379"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a10">00379</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a9">getMemoryManager</a>()<font class="keyword"> const</font>
00380 <font class="keyword">    </font>{
00381         <font class="keywordflow">return</font> m_pointerInfo.m_memoryManager;
00382     }
00383 
00384     <a class="code" href="classXalanMemMgrAutoPtrArray.html">XalanMemMgrAutoPtrArray&lt;Type&gt;</a>&amp;
<a name="l00385"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a11">00385</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a11">operator++ </a>()<font class="keyword"></font>
00386 <font class="keyword">    </font>{
00387         ++m_pointerInfo.m_size;
00388 
00389         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00390     }
00391 
00392     <font class="comment">/* Since this class is not reference-counted, I don't see how this</font>
00393 <font class="comment">       could work, since the destruction of the temporary will free</font>
00394 <font class="comment">       the controlled pointer.</font>
00395 <font class="comment">    XalanMemMgrAutoPtrArray&lt;Type&gt;</font>
00396 <font class="comment">    operator++ (int)</font>
00397 <font class="comment">    {</font>
00398 <font class="comment">        XalanMemMgrAutoPtrArray&lt;Type&gt; temp = *this;</font>
00399 <font class="comment">        ++*this;</font>
00400 <font class="comment"></font>
00401 <font class="comment">        return temp;</font>
00402 <font class="comment">    }</font>
00403 <font class="comment">    */</font>
00404 
00405     MemMgrAutoPtrArrayData
<a name="l00406"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a12">00406</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a12">release</a>()<font class="keyword"></font>
00407 <font class="keyword">    </font>{
00408         MemMgrAutoPtrArrayData tmp = m_pointerInfo;
00409 
00410         m_pointerInfo.reset(0, 0, 0); 
00411 
00412         <font class="keywordflow">return</font> MemMgrAutoPtrArrayData(tmp);
00413     }
00414 
00415     Type*
<a name="l00416"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a13">00416</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a13">releasePtr</a>()<font class="keyword"></font>
00417 <font class="keyword">    </font>{       
00418         MemMgrAutoPtrArrayData  tmp = <a class="code" href="classXalanMemMgrAutoPtrArray.html#a12">release</a>();
00419 
00420         <font class="keywordflow">return</font> tmp.m_dataArray;
00421     }
00422 
00423     <font class="keywordtype">void</font>
<a name="l00424"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a14">00424</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a14">reset</a>( 
00425             MemoryManager*  theManager = 0,
00426             Type*           thePointer = 0 ,
00427             size_type       size = 0)<font class="keyword"></font>
00428 <font class="keyword">    </font>{       
00429         m_pointerInfo.deallocate();
00430 
00431         m_pointerInfo.reset(theManager, thePointer, size);
00432     }
00433     
00434     Type&amp;
<a name="l00435"></a><a class="code" href="classXalanMemMgrAutoPtrArray.html#a15">00435</a>     <a class="code" href="classXalanMemMgrAutoPtrArray.html#a15">operator[]</a>(size_type    index)<font class="keyword"> const</font>
00436 <font class="keyword">    </font>{
00437         <font class="keywordflow">return</font> m_pointerInfo.m_dataArray[index];
00438     }
00439 
00440 <font class="keyword">private</font>:
00441 
00442     <font class="comment">// data member</font>
00443     MemMgrAutoPtrArrayData m_pointerInfo;
00444 };
00445 
00446 
00447 
00448 
00449 XALAN_CPP_NAMESPACE_END
00450 
00451 
00452 
00453 <font class="preprocessor">#endif  // if !defined(XALANMEMMGRAUTOPTR_HEADER_GUARD_1357924680)</font>
</font></pre></div><p align="center"><a href="diagramnotes.html">Interpreting class diagrams</a></p>
<p><FONT color="#000000" face="arial,helvetica,sanserif" size="-1">
<i><A href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</A> and 
<A href="http://www.research.att.com/sw/tools/graphviz/">GraphViz</A> are used to generate this API documentation from the Xalan-C header files.</I></FONT></p>

<TABLE border="0" cellpadding="0" cellspacing="0" width="820"><TR><TD bgcolor="#0086b2"><IMG height="1" src="../resources/dot.gif" width="1" alt="dot"></TD></TR></TABLE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="80%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xalan-C++ XSLT Processor Version 1.10</B><BR>
			Copyright &copy; 1999-2004 The Apache Software Foundation. All Rights Reserved.</i></p>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0" ALT="Apache Logo">
		</TD>
	</TR>
</TABLE>
