<HTML><HEAD><TITLE>Xalan-C++ API Documentation</TITLE></HEAD>
<BODY>
<h2 align="center">Xalan-C++ API Documentation</h2>
<h3 align="center">The Xalan C++ XSLT Processor Version 1.10</h3>
</BODY>
<!-- Generated by Doxygen 1.2.8.1 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>XalanMap.hpp</h1><a href="XalanMap_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">/*</font>
00002 <font class="comment"> * Copyright 1999-2004 The Apache Software Foundation.</font>
00003 <font class="comment"> *</font>
00004 <font class="comment"> * Licensed under the Apache License, Version 2.0 (the "License");</font>
00005 <font class="comment"> * you may not use this file except in compliance with the License.</font>
00006 <font class="comment"> * You may obtain a copy of the License at</font>
00007 <font class="comment"> *</font>
00008 <font class="comment"> *     http://www.apache.org/licenses/LICENSE-2.0</font>
00009 <font class="comment"> *</font>
00010 <font class="comment"> * Unless required by applicable law or agreed to in writing, software</font>
00011 <font class="comment"> * distributed under the License is distributed on an "AS IS" BASIS,</font>
00012 <font class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</font>
00013 <font class="comment"> * See the License for the specific language governing permissions and</font>
00014 <font class="comment"> * limitations under the License.</font>
00015 <font class="comment"> */</font>
00016 
00017 <font class="preprocessor">#if !defined(XALANMAP_HEADER_GUARD_1357924680)</font>
<a name="l00018"></a><a class="code" href="XalanMap_8hpp.html#a0">00018</a> <font class="preprocessor"></font><font class="preprocessor">#define XALANMAP_HEADER_GUARD_1357924680</font>
00019 <font class="preprocessor"></font>
00020 
00021 <font class="comment">// Base include file.  Must be first.</font>
00022 <font class="preprocessor">#include &lt;<a class="code" href="PlatformDefinitions_8hpp.html">xalanc/Include/PlatformDefinitions.hpp</a>&gt;</font>
00023 
00024 
00025 
00026 <font class="preprocessor">#include &lt;cstddef&gt;</font>
00027 <font class="preprocessor">#include &lt;algorithm&gt;</font>
00028 <font class="preprocessor">#include &lt;functional&gt;</font>
00029 <font class="preprocessor">#include &lt;utility&gt;</font>
00030 
00031 
00032 <font class="preprocessor">#include &lt;<a class="code" href="XalanVector_8hpp.html">xalanc/Include/XalanVector.hpp</a>&gt;</font>
00033 <font class="preprocessor">#include &lt;<a class="code" href="XalanList_8hpp.html">xalanc/Include/XalanList.hpp</a>&gt;</font>
00034 
00035 
00036 
00037 XALAN_CPP_NAMESPACE_BEGIN
00038 
00039 <font class="preprocessor">#if defined(_MSC_VER)</font>
00040 <font class="preprocessor"></font><font class="preprocessor">#pragma warning(push)</font>
00041 <font class="preprocessor"></font><font class="preprocessor">#pragma warning(disable: 4189)</font>
00042 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00043 <font class="preprocessor"></font>
<a name="l00044"></a><a class="code" href="XalanMap_8hpp.html#a1">00044</a> <font class="keyword">typedef</font> size_t  size_type;
00045 
00046 template &lt;class Key&gt;
<a name="l00047"></a><a class="code" href="classXalanHasher.html">00047</a> <font class="keyword">class </font><a class="code" href="classXalanHasher.html">XalanHasher</a> : <font class="keyword">public</font> XALAN_STD_QUALIFIER unary_function&lt;Key, size_type&gt;
00048 {
00049 <font class="keyword">public</font>:
<a name="l00050"></a><a class="code" href="classXalanHasher.html#a0">00050</a>     size_type <a class="code" href="classXalanHasher.html#a0">operator()</a>(<font class="keyword">const</font> Key&amp; key)<font class="keyword"> const</font>
00051 <font class="keyword">    </font>{
00052         <font class="keyword">const</font> <font class="keywordtype">char</font> *byteArray = reinterpret_cast&lt;const char*&gt;(&amp;key);
00053 
00054         size_type result = 0;
00055 
00056         <font class="keywordflow">for</font> (size_type i = 0; i &lt; <font class="keyword">sizeof</font>(Key); ++i)
00057         {
00058             result = (result &lt;&lt; 1) ^ byteArray[i];
00059         }
00060 
00061         <font class="keywordflow">return</font> result;
00062     }
00063 };
00064 
00065 template &lt;class Key&gt;
<a name="l00066"></a><a class="code" href="structXalanMapKeyTraits.html">00066</a> <font class="keyword">struct </font><a class="code" href="structXalanMapKeyTraits.html">XalanMapKeyTraits</a>
00067 {
<a name="l00068"></a><a class="code" href="structXalanMapKeyTraits.html#s0">00068</a>     <font class="keyword">typedef</font> <a class="code" href="classXalanHasher.html">XalanHasher&lt;Key&gt;</a>                    <a class="code" href="structhash__null__terminated__arrays.html">Hasher</a>;
<a name="l00069"></a><a class="code" href="structXalanMapKeyTraits.html#s1">00069</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER equal_to&lt;Key&gt;   <a class="code" href="structequal__null__terminated__arrays.html">Comparator</a>;
00070 };
00071 
00072 
00073 template &lt;class Key&gt;
<a name="l00074"></a><a class="code" href="structXalanHashMemberPointer.html">00074</a> <font class="keyword">struct </font><a class="code" href="structXalanHashMemberPointer.html">XalanHashMemberPointer</a>
00075 {
00076 
<a name="l00077"></a><a class="code" href="structXalanHashMemberPointer.html#a0">00077</a>     size_type <a class="code" href="structXalanHashMemberPointer.html#a0">operator() </a>(<font class="keyword">const</font> Key * key)<font class="keyword"> const</font>
00078 <font class="keyword">    </font>{
00079         assert (key != 0);
00080         <font class="keywordflow">return</font> key-&gt;hash();
00081     }
00082 };
00083 
00084 template &lt;class Key&gt;
<a name="l00085"></a><a class="code" href="structXalanHashMemberReference.html">00085</a> <font class="keyword">struct </font><a class="code" href="structXalanHashMemberReference.html">XalanHashMemberReference</a>
00086 {
00087 
<a name="l00088"></a><a class="code" href="structXalanHashMemberReference.html#a0">00088</a>     size_type <a class="code" href="structXalanHashMemberReference.html#a0">operator() </a>(<font class="keyword">const</font> Key&amp; key)<font class="keyword"> const</font>
00089 <font class="keyword">    </font>{
00090         <font class="keywordflow">return</font> key.hash();
00091     }
00092 };
00093 
00094 
00095 
00096 template &lt;class Value&gt;
<a name="l00097"></a><a class="code" href="structXalanMapIteratorTraits.html">00097</a> <font class="keyword">struct </font><a class="code" href="structXalanMapIteratorTraits.html">XalanMapIteratorTraits</a>
00098 {
<a name="l00099"></a><a class="code" href="structXalanMapIteratorTraits.html#s0">00099</a>     <font class="keyword">typedef</font> Value           value_type;
<a name="l00100"></a><a class="code" href="structXalanMapIteratorTraits.html#s1">00100</a>     <font class="keyword">typedef</font> Value&amp;          reference;
<a name="l00101"></a><a class="code" href="structXalanMapIteratorTraits.html#s2">00101</a>     <font class="keyword">typedef</font> Value*          pointer;
00102 };
00103 
00104 template &lt;class Value&gt;
<a name="l00105"></a><a class="code" href="structXalanMapConstIteratorTraits.html">00105</a> <font class="keyword">struct </font><a class="code" href="structXalanMapConstIteratorTraits.html">XalanMapConstIteratorTraits</a>
00106 {
<a name="l00107"></a><a class="code" href="structXalanMapConstIteratorTraits.html#s0">00107</a>     <font class="keyword">typedef</font> Value           value_type;
<a name="l00108"></a><a class="code" href="structXalanMapConstIteratorTraits.html#s1">00108</a>     <font class="keyword">typedef</font> <font class="keyword">const</font> Value&amp;    reference;
<a name="l00109"></a><a class="code" href="structXalanMapConstIteratorTraits.html#s2">00109</a>     <font class="keyword">typedef</font> <font class="keyword">const</font> Value*    pointer;
00110 };
00111 
00112 template &lt;class XalanMapTraits, class BaseIterator&gt;
<a name="l00113"></a><a class="code" href="structXalanMapIterator.html">00113</a> <font class="keyword">struct </font><a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>
00114 {
<a name="l00115"></a><a class="code" href="structXalanMapIterator.html#s0">00115</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> XalanMapTraits::value_type         value_type;
<a name="l00116"></a><a class="code" href="structXalanMapIterator.html#s1">00116</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> XalanMapTraits::reference          reference;
<a name="l00117"></a><a class="code" href="structXalanMapIterator.html#s2">00117</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> XalanMapTraits::pointer            pointer;
00118 
<a name="l00119"></a><a class="code" href="structXalanMapIterator.html#s3">00119</a>     <font class="keyword">typedef</font> ptrdiff_t                           difference_type;
<a name="l00120"></a><a class="code" href="structXalanMapIterator.html#s4">00120</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER bidirectional_iterator_tag iterator_category;
00121 
00122     <font class="keyword">typedef</font> <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&lt;
00123         <a class="code" href="structXalanMapIteratorTraits.html">XalanMapIteratorTraits&lt;value_type&gt;</a>, 
<a name="l00124"></a><a class="code" href="structXalanMapIterator.html#s5">00124</a>         BaseIterator&gt;                                   <a class="code" href="structXalanDequeIterator.html">Iterator</a>; 
00125 
<a name="l00126"></a><a class="code" href="structXalanMapIterator.html#a0">00126</a>     <a class="code" href="structXalanMapIterator.html#a0">XalanMapIterator</a>(<font class="keyword">const</font> <a class="code" href="structXalanDequeIterator.html">Iterator</a> &amp; theRhs) :
00127         baseIterator(theRhs.baseIterator)
00128     {
00129     }
00130 
<a name="l00131"></a><a class="code" href="structXalanMapIterator.html#a1">00131</a>     <a class="code" href="structXalanMapIterator.html#a0">XalanMapIterator</a>(<font class="keyword">const</font> BaseIterator &amp; theRhs) :
00132         baseIterator(theRhs)
00133     {
00134     }
00135 
<a name="l00136"></a><a class="code" href="structXalanMapIterator.html#a2">00136</a>     <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a> <a class="code" href="structXalanMapIterator.html#a3">operator++</a>(<font class="keywordtype">int</font>)<font class="keyword"></font>
00137 <font class="keyword">    </font>{
00138         <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a> temp(*<font class="keyword">this</font>);
00139         ++baseIterator;
00140         <font class="keywordflow">return</font> temp;
00141     }
00142 
<a name="l00143"></a><a class="code" href="structXalanMapIterator.html#a3">00143</a>     <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&amp; <a class="code" href="structXalanMapIterator.html#a3">operator++</a>()<font class="keyword"></font>
00144 <font class="keyword">    </font>{
00145         ++baseIterator;
00146         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00147     }
00148 
<a name="l00149"></a><a class="code" href="structXalanMapIterator.html#a4">00149</a>     reference <a class="code" href="structXalanMapIterator.html#a4">operator*</a>()<font class="keyword"> const</font>
00150 <font class="keyword">    </font>{
00151         <font class="keywordflow">return</font> *baseIterator-&gt;value;
00152     }
00153 
<a name="l00154"></a><a class="code" href="structXalanMapIterator.html#a5">00154</a>     pointer <a class="code" href="structXalanMapIterator.html#a5">operator-&gt;</a>()<font class="keyword"> const</font>
00155 <font class="keyword">    </font>{
00156         <font class="keywordflow">return</font> baseIterator-&gt;value;
00157     }
00158 
<a name="l00159"></a><a class="code" href="structXalanMapIterator.html#a6">00159</a>     <font class="keywordtype">bool</font> <a class="code" href="ElemAttributeSet_8hpp.html#a1">operator==</a>(<font class="keyword">const</font> <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&amp; theRhs)<font class="keyword"> const</font>
00160 <font class="keyword">    </font>{
00161         <font class="keywordflow">return</font> theRhs.baseIterator == baseIterator;
00162     }
00163 
<a name="l00164"></a><a class="code" href="structXalanMapIterator.html#a7">00164</a>     <font class="keywordtype">bool</font> <a class="code" href="XObject_8hpp.html#a3">operator!=</a>(<font class="keyword">const</font> <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&amp; theRhs)<font class="keyword"> const</font>
00165 <font class="keyword">    </font>{
00166         <font class="keywordflow">return</font> !(theRhs == *<font class="keyword">this</font>);
00167     }
00168 
<a name="l00169"></a><a class="code" href="structXalanMapIterator.html#m0">00169</a>     BaseIterator baseIterator;
00170 };
00171 
00172 
00173 
00178 <font class="keyword">template</font> &lt;
00179         <font class="keyword">class </font>Key, 
00180         <font class="keyword">class </font>Value,
00181         <font class="keyword">class </font>KeyTraits = <a class="code" href="structXalanMapKeyTraits.html">XalanMapKeyTraits&lt;Key&gt;</a> &gt;
<a name="l00182"></a><a class="code" href="classXalanMap.html">00182</a> <font class="keyword">class </font><a class="code" href="classXalanMap.html">XalanMap</a>
00183 {
00184 <font class="keyword">public</font>:
00192 
<a name="l00193"></a><a class="code" href="classXalanMap.html#s0">00193</a>     <font class="keyword">typedef</font> Key                 key_type;
<a name="l00194"></a><a class="code" href="classXalanMap.html#s1">00194</a>     <font class="keyword">typedef</font> Value               data_type;
<a name="l00195"></a><a class="code" href="classXalanMap.html#s2">00195</a>     <font class="keyword">typedef</font> size_t              size_type;
00196 
<a name="l00197"></a><a class="code" href="classXalanMap.html#s3">00197</a>     <font class="keyword">typedef</font> XALAN_STD_QUALIFIER pair&lt;const key_type, data_type&gt;   value_type;
00198 
<a name="l00199"></a><a class="code" href="structXalanMap_1_1Entry.html">00199</a>     <font class="keyword">struct </font>Entry
00200     {
<a name="l00201"></a><a class="code" href="structXalanMap_1_1Entry.html#m0">00201</a>         value_type* value;
<a name="l00202"></a><a class="code" href="structXalanMap_1_1Entry.html#m1">00202</a>         <font class="keywordtype">bool</font>        erased;
00203 
<a name="l00204"></a><a class="code" href="structXalanMap_1_1Entry.html#a0">00204</a>         <a class="code" href="structXalanMap_1_1Entry.html#a0">Entry</a>(value_type* theValue) :
00205             value(theValue),
00206             erased(false)
00207         {
00208         }
00209     };
00210 
<a name="l00211"></a><a class="code" href="classXalanMap.html#s4">00211</a>     <font class="keyword">typedef</font> <a class="code" href="classXalanList.html">XalanList&lt;Entry&gt;</a>                                <a class="code" href="classXalanList.html">EntryListType</a>;
00212 
<a name="l00213"></a><a class="code" href="classXalanMap.html#s5">00213</a>     <font class="keyword">typedef</font> XalanVector&lt;typename EntryListType::iterator&gt;   BucketType;
<a name="l00214"></a><a class="code" href="classXalanMap.html#s6">00214</a>     <font class="keyword">typedef</font> XalanVector&lt;BucketType, ConstructWithMemoryManagerTraits&lt;BucketType&gt; &gt;      BucketTableType;
00215 
<a name="l00216"></a><a class="code" href="classXalanMap.html#s7">00216</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> EntryListType::iterator       EntryListIterator;
<a name="l00217"></a><a class="code" href="classXalanMap.html#s8">00217</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BucketTableType::iterator     TableIterator;
<a name="l00218"></a><a class="code" href="classXalanMap.html#s9">00218</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> BucketType::iterator          BucketIterator;
00219 
00220     <font class="keyword">typedef</font> <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&lt;
00221                 <a class="code" href="structXalanMapIteratorTraits.html">XalanMapIteratorTraits&lt;value_type&gt;</a>, 
<a name="l00222"></a><a class="code" href="classXalanMap.html#s10">00222</a>                 <font class="keyword">typename</font> EntryListType::iterator&gt;           iterator;
00223     <font class="keyword">typedef</font> <a class="code" href="structXalanMapIterator.html">XalanMapIterator</a>&lt;
00224                 <a class="code" href="structXalanMapConstIteratorTraits.html">XalanMapConstIteratorTraits&lt;value_type&gt;</a>, 
<a name="l00225"></a><a class="code" href="classXalanMap.html#s11">00225</a>                 <font class="keyword">typename</font> EntryListType::iterator&gt;     const_iterator;
00226 
<a name="l00227"></a><a class="code" href="classXalanMap.html#s12">00227</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> <a class="code" href="structMemoryManagedConstructionTraits.html">MemoryManagedConstructionTraits&lt;key_type&gt;</a>::Constructor  <a class="code" href="structMemoryManagedConstructionTraits.html">FirstConstructor</a>;
<a name="l00228"></a><a class="code" href="classXalanMap.html#s13">00228</a>     <font class="keyword">typedef</font> <font class="keyword">typename</font> <a class="code" href="structMemoryManagedConstructionTraits.html">MemoryManagedConstructionTraits&lt;data_type&gt;</a>::Constructor <a class="code" href="structMemoryManagedConstructionTraits.html">SecondConstructor</a>;
00229 
00230     <font class="keyword">enum</font>
00231     {
00232         eDefaultMinBuckets = 29u,
00233         eDefaultEraseThreshold = 50u,
00234         eMinimumBucketSize = 5u
00235     };
00236 
00237 
<a name="l00238"></a><a class="code" href="classXalanMap.html#a0">00238</a>     <a class="code" href="classXalanMap.html#a0">XalanMap</a>(
00239             MemoryManagerType&amp;  theMemoryManager,
00240             <font class="keywordtype">float</font>               loadFactor = 0.75,
00241             size_type           minBuckets = eDefaultMinBuckets,
00242             size_type           eraseThreshold = eDefaultEraseThreshold) :
00243         m_memoryManager(&amp;theMemoryManager),
00244         m_loadFactor(loadFactor),
00245         m_minBuckets(minBuckets),
00246         m_size(0),
00247         m_entries(theMemoryManager),
00248         m_freeEntries(theMemoryManager),
00249         m_buckets(theMemoryManager),
00250         m_eraseCount(0),
00251         m_eraseThreshold(eraseThreshold)
00252     {
00253     }
00254 
<a name="l00255"></a><a class="code" href="classXalanMap.html#a1">00255</a>     <a class="code" href="classXalanMap.html#a0">XalanMap</a>(
00256             <font class="keyword">const</font> <a class="code" href="classXalanMap.html">XalanMap</a>&amp;     theRhs,
00257             MemoryManagerType&amp;  theMemoryManager) :
00258         m_memoryManager(&amp;theMemoryManager),
00259         m_loadFactor(theRhs.m_loadFactor),
00260         m_minBuckets(theRhs.m_minBuckets),
00261         m_size(0),
00262         m_entries(theMemoryManager),
00263         m_freeEntries(theMemoryManager),
00264         m_buckets(
00265             size_type(m_loadFactor * theRhs.size()) + 1,
00266             BucketType(*m_memoryManager),
00267             theMemoryManager),
00268         m_eraseCount(0),
00269         m_eraseThreshold(theRhs.m_eraseThreshold)
00270     {
00271         const_iterator entry = theRhs.<a class="code" href="classXalanMap.html#a7">begin</a>();
00272 
00273         <font class="keywordflow">while</font>(entry != theRhs.<a class="code" href="classXalanMap.html#a9">end</a>())
00274         {
00275             <a class="code" href="DOMStringHelper_8hpp.html#a79">insert</a>(*entry);
00276             ++entry;
00277         }
00278 
00279         assert(m_size == theRhs.m_size);
00280     }
00281 
00282     MemoryManagerType&amp;
<a name="l00283"></a><a class="code" href="classXalanMap.html#a2">00283</a>     <a class="code" href="classXalanMap.html#a2">getMemoryManager</a>()<font class="keyword"></font>
00284 <font class="keyword">    </font>{
00285         assert (m_memoryManager != 0);
00286 
00287         <font class="keywordflow">return</font> *m_memoryManager;
00288     }
00289 
<a name="l00290"></a><a class="code" href="classXalanMap.html#a3">00290</a>     <a class="code" href="classXalanMap.html#a3">~XalanMap</a>()<font class="keyword"></font>
00291 <font class="keyword">    </font>{
00292         <a class="code" href="classXalanMap.html#b2">doRemoveEntries</a>();
00293 
00294         <font class="keywordflow">if</font> (!m_buckets.empty())
00295         {
00296             EntryListIterator   toRemove = m_freeEntries.<a class="code" href="classXalanList.html#a4">begin</a>();
00297 
00298             <font class="keywordflow">while</font>(toRemove != m_freeEntries.<a class="code" href="classXalanList.html#a6">end</a>())
00299             {
00300                 <a class="code" href="classXalanMap.html#b8">deallocate</a>(toRemove-&gt;value);
00301                 ++toRemove;
00302             }      
00303         }
00304     }
00305 
00306     <a class="code" href="classXalanMap.html">XalanMap</a>&amp;
<a name="l00307"></a><a class="code" href="classXalanMap.html#a4">00307</a>     <a class="code" href="classXalanMap.html#a4">operator=</a>(<font class="keyword">const</font> <a class="code" href="classXalanMap.html">XalanMap</a>&amp;   theRhs)<font class="keyword"> </font>
00308 <font class="keyword">    </font>{
00309         <a class="code" href="classXalanMap.html">XalanMap</a>    theTemp(theRhs, *m_memoryManager);
00310 
00311         <a class="code" href="XalanVector_8hpp.html#a2">swap</a>(theTemp);
00312 
00313         <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00314     }
00315 
<a name="l00316"></a><a class="code" href="classXalanMap.html#a5">00316</a>     size_type <a class="code" href="classXalanMap.html#a5">size</a>()<font class="keyword"> const</font>
00317 <font class="keyword">    </font>{
00318         <font class="keywordflow">return</font> m_size;
00319     }
00320 
<a name="l00321"></a><a class="code" href="classXalanMap.html#a6">00321</a>     <font class="keywordtype">bool</font> <a class="code" href="classXalanMap.html#a6">empty</a>()<font class="keyword"> const</font>
00322 <font class="keyword">    </font>{
00323         <font class="keywordflow">return</font> m_size == 0;
00324     }
00325 
<a name="l00326"></a><a class="code" href="classXalanMap.html#a7">00326</a>     iterator <a class="code" href="classXalanMap.html#a7">begin</a>()<font class="keyword"></font>
00327 <font class="keyword">    </font>{
00328         <font class="keywordflow">return</font> m_entries.<a class="code" href="classXalanList.html#a4">begin</a>();
00329     }
00330 
<a name="l00331"></a><a class="code" href="classXalanMap.html#a8">00331</a>     const_iterator <a class="code" href="classXalanMap.html#a7">begin</a>()<font class="keyword"> const</font>
00332 <font class="keyword">    </font>{
00333         <font class="keywordflow">return</font>  const_cast&lt;XalanMap*&gt;(<font class="keyword">this</font>)-&gt;begin();
00334     }
00335 
<a name="l00336"></a><a class="code" href="classXalanMap.html#a9">00336</a>     iterator <a class="code" href="classXalanMap.html#a9">end</a>()<font class="keyword"></font>
00337 <font class="keyword">    </font>{
00338         <font class="keywordflow">return</font> m_entries.<a class="code" href="classXalanList.html#a6">end</a>();
00339     }
00340 
<a name="l00341"></a><a class="code" href="classXalanMap.html#a10">00341</a>     const_iterator <a class="code" href="classXalanMap.html#a9">end</a>()<font class="keyword"> const </font>
00342 <font class="keyword">    </font>{
00343         <font class="keywordflow">return</font> const_cast&lt;XalanMap*&gt;(<font class="keyword">this</font>)-&gt;end();
00344     }
00345 
<a name="l00346"></a><a class="code" href="classXalanMap.html#a11">00346</a>     iterator <a class="code" href="classXalanMap.html#a11">find</a>(<font class="keyword">const</font> key_type&amp; key)<font class="keyword"></font>
00347 <font class="keyword">    </font>{
00348         <font class="keywordflow">if</font> (m_size != 0)
00349         {
00350             assert(m_buckets.empty() == <font class="keyword">false</font>);
00351 
00352             <font class="keyword">const</font> size_type     index = <a class="code" href="classXalanMap.html#b4">doHash</a>(key);
00353             assert(index &lt; m_buckets.size());
00354 
00355             BucketType&amp;     bucket = m_buckets[index];
00356             BucketIterator  pos = bucket.begin();
00357 
00358             <font class="keywordflow">while</font> (pos != bucket.end())
00359             {
00360                 <font class="keywordflow">if</font> (!(*pos)-&gt;erased &amp;&amp; <a class="code" href="classXalanMap.html#n1">m_equals</a>(key, (*pos)-&gt;value-&gt;first))
00361                 {
00362                     <font class="keywordflow">return</font> <a class="code" href="classXalanMap.html#s10">iterator</a>(*pos);
00363                 }
00364                 ++pos;
00365             }
00366         }
00367 
00368         <font class="keywordflow">return</font> <a class="code" href="classXalanMap.html#a9">end</a>();
00369     }
00370 
<a name="l00371"></a><a class="code" href="classXalanMap.html#a12">00371</a>     const_iterator <a class="code" href="classXalanMap.html#a11">find</a>(<font class="keyword">const</font> key_type&amp; key)<font class="keyword"> const </font>
00372 <font class="keyword">    </font>{
00373         <font class="keywordflow">return</font> const_cast&lt;XalanMap *&gt;(<font class="keyword">this</font>)-&gt;find(key);
00374     }
00375 
<a name="l00376"></a><a class="code" href="classXalanMap.html#a13">00376</a>     data_type &amp; <a class="code" href="classXalanMap.html#a13">operator[]</a>(<font class="keyword">const</font> key_type&amp; key)<font class="keyword"></font>
00377 <font class="keyword">    </font>{
00378         iterator pos = <a class="code" href="classXalanMap.html#a11">find</a>(key);
00379 
00380         <font class="keywordflow">if</font> (pos == <a class="code" href="classXalanMap.html#a9">end</a>())
00381         {
00382             pos = <a class="code" href="classXalanMap.html#b0">doCreateEntry</a>(key);
00383         }
00384 
00385         <font class="keywordflow">return</font> (*pos).second;
00386     }
00387 
00388     <font class="keywordtype">void</font>
<a name="l00389"></a><a class="code" href="classXalanMap.html#a14">00389</a>     <a class="code" href="DOMStringHelper_8hpp.html#a79">insert</a>(<font class="keyword">const</font> value_type&amp;    value)<font class="keyword"></font>
00390 <font class="keyword">    </font>{
00391         <a class="code" href="DOMStringHelper_8hpp.html#a79">insert</a>(value.first, value.second);
00392     }
00393 
<a name="l00394"></a><a class="code" href="classXalanMap.html#a15">00394</a>     <font class="keywordtype">void</font> <a class="code" href="DOMStringHelper_8hpp.html#a79">insert</a>(<font class="keyword">const</font> key_type&amp; key, <font class="keyword">const</font> data_type&amp; data)<font class="keyword"></font>
00395 <font class="keyword">    </font>{
00396         <font class="keyword">const</font> const_iterator    pos = <a class="code" href="classXalanMap.html#a11">find</a>(key);
00397 
00398         <font class="keywordflow">if</font> (pos == <a class="code" href="classXalanMap.html#a9">end</a>())
00399         {
00400             <a class="code" href="classXalanMap.html#b0">doCreateEntry</a>(key, &amp;data);
00401         }
00402     }
00403 
<a name="l00404"></a><a class="code" href="classXalanMap.html#a16">00404</a>     <font class="keywordtype">void</font> <a class="code" href="DOMStringHelper_8hpp.html#a81">erase</a>(iterator pos)<font class="keyword"></font>
00405 <font class="keyword">    </font>{
00406         <font class="keywordflow">if</font> (pos != <a class="code" href="classXalanMap.html#a9">end</a>())
00407         {
00408             <a class="code" href="classXalanMap.html#b3">doErase</a>(pos);
00409         }
00410     }
00411 
<a name="l00412"></a><a class="code" href="classXalanMap.html#a17">00412</a>     size_type <a class="code" href="DOMStringHelper_8hpp.html#a81">erase</a>(<font class="keyword">const</font> key_type&amp; key)<font class="keyword"></font>
00413 <font class="keyword">    </font>{
00414         <font class="keyword">const</font> iterator  pos = <a class="code" href="classXalanMap.html#a11">find</a>(key);
00415 
00416         <font class="keywordflow">if</font> (pos != <a class="code" href="classXalanMap.html#a9">end</a>())
00417         {
00418             <a class="code" href="classXalanMap.html#b3">doErase</a>(pos);
00419 
00420             <font class="keywordflow">return</font> 1;
00421         }
00422         <font class="keywordflow">else</font>
00423         {
00424             <font class="keywordflow">return</font> 0;
00425         }
00426     }
00427 
<a name="l00428"></a><a class="code" href="classXalanMap.html#a18">00428</a>     <font class="keywordtype">void</font> <a class="code" href="DOMStringHelper_8hpp.html#a80">clear</a>()<font class="keyword"> </font>
00429 <font class="keyword">    </font>{
00430         <a class="code" href="classXalanMap.html#b2">doRemoveEntries</a>();
00431 
00432         TableIterator   bucketPos = m_buckets.begin();
00433 
00434         <font class="keywordflow">while</font> (bucketPos != m_buckets.end())
00435         {
00436             bucketPos-&gt;clear();
00437             ++bucketPos;
00438         }
00439 
00440         m_eraseCount = 0;
00441 
00442         assert(0 == m_size);
00443         assert(m_entries.<a class="code" href="classXalanList.html#a15">empty</a>());
00444     }
00445 
<a name="l00446"></a><a class="code" href="classXalanMap.html#a19">00446</a>     <font class="keywordtype">void</font> <a class="code" href="XalanVector_8hpp.html#a2">swap</a>(<a class="code" href="classXalanMap.html">XalanMap</a>&amp; theRhs)<font class="keyword"></font>
00447 <font class="keyword">    </font>{
00448         <font class="keyword">const</font> size_type tempSize = m_size;
00449         m_size = theRhs.m_size;
00450         theRhs.m_size = tempSize;
00451 
00452         MemoryManagerType* <font class="keyword">const</font>    tempMemoryManager = m_memoryManager;
00453         m_memoryManager = theRhs.m_memoryManager;
00454         theRhs.m_memoryManager = tempMemoryManager;
00455 
00456         <font class="keyword">const</font> size_type     tempEraseCount = m_eraseCount;
00457         m_eraseCount = theRhs.m_eraseCount;
00458         theRhs.m_eraseCount = tempEraseCount;
00459 
00460         <font class="keyword">const</font> size_type     tempEraseTheshold = m_eraseThreshold;
00461         m_eraseThreshold = theRhs.m_eraseThreshold;
00462         theRhs.m_eraseThreshold = tempEraseTheshold;
00463 
00464         m_entries.<a class="code" href="classXalanList.html#a25">swap</a>(theRhs.m_entries);
00465         m_freeEntries.<a class="code" href="classXalanList.html#a25">swap</a>(theRhs.m_freeEntries);
00466         m_buckets.swap(theRhs.m_buckets);
00467     }
00468 
00469 <font class="keyword">protected</font>:
00470 
<a name="l00471"></a><a class="code" href="classXalanMap.html#b0">00471</a>     iterator <a class="code" href="classXalanMap.html#b0">doCreateEntry</a>(<font class="keyword">const</font> key_type &amp; key, <font class="keyword">const</font> data_type*  data = 0)<font class="keyword"></font>
00472 <font class="keyword">    </font>{
00473         <font class="comment">// if there are no buckets, create initial minimum set of buckets</font>
00474         <font class="keywordflow">if</font> (m_buckets.empty())
00475         {
00476             m_buckets.insert(
00477                 m_buckets.begin(),
00478                 m_minBuckets,
00479                 <a class="code" href="classXalanMap.html#s5">BucketType</a>(*m_memoryManager));
00480         }
00481 
00482         <font class="comment">// if the load factor has been reached, rehash</font>
00483         <font class="keywordflow">if</font> (<a class="code" href="XalanMap_8hpp.html#a1">size_type</a>(m_loadFactor * <a class="code" href="classXalanMap.html#a5">size</a>()) &gt; m_buckets.size())
00484         {
00485             <a class="code" href="classXalanMap.html#b6">rehash</a>();
00486         }
00487 
00488         <font class="keyword">const</font> size_type     index = <a class="code" href="classXalanMap.html#b4">doHash</a>(key);
00489 
00490         <font class="keywordflow">if</font> (m_freeEntries.<a class="code" href="classXalanList.html#a15">empty</a>())
00491         {
00492             m_freeEntries.<a class="code" href="classXalanList.html#a16">push_back</a>(Entry(<a class="code" href="classXalanMap.html#b7">allocate</a>(1)));
00493         }
00494 
00495         <font class="comment">// insert a new entry as the first position in the bucket</font>
00496         Entry&amp;  newEntry = m_freeEntries.<a class="code" href="classXalanList.html#a13">back</a>();
00497         newEntry.erased = <font class="keyword">false</font>;
00498 
00499         FirstConstructor::construct(
00500             const_cast&lt;key_type*&gt;(&amp;newEntry.value-&gt;first),
00501             key,
00502             *m_memoryManager);
00503 
00504         <font class="keywordflow">if</font> (data != 0)
00505         {
00506             SecondConstructor::construct(
00507                 &amp;newEntry.value-&gt;second,
00508                 *data,
00509                 *m_memoryManager);
00510         }
00511         <font class="keywordflow">else</font>
00512         {
00513              SecondConstructor::construct(
00514                  &amp;newEntry.value-&gt;second,
00515                  *m_memoryManager);
00516         }
00517 
00518         m_entries.<a class="code" href="classXalanList.html#a22">splice</a>(m_entries.<a class="code" href="classXalanList.html#a6">end</a>(), m_freeEntries, --m_freeEntries.<a class="code" href="classXalanList.html#a6">end</a>());
00519 
00520         m_buckets[index].push_back(--m_entries.<a class="code" href="classXalanList.html#a6">end</a>());
00521 
00522         ++m_size;
00523 
00524         <font class="keywordflow">return</font> <a class="code" href="classXalanMap.html#s10">iterator</a>(--m_entries.<a class="code" href="classXalanList.html#a6">end</a>());
00525     }
00526 
<a name="l00527"></a><a class="code" href="classXalanMap.html#b1">00527</a>     <font class="keywordtype">void</font> <a class="code" href="classXalanMap.html#b1">doRemoveEntry</a>(<font class="keyword">const</font> iterator &amp; toRemovePos)<font class="keyword"></font>
00528 <font class="keyword">    </font>{   
00529         value_type&amp; toRemove = *toRemovePos;
00530 <font class="preprocessor">#if defined(_MSC_VER) &amp;&amp; _MSC_VER &lt;= 1300</font>
00531 <font class="preprocessor"></font>        toRemove.value_type::~value_type();
00532 <font class="preprocessor">#else</font>
00533 <font class="preprocessor"></font>        toRemove.~value_type();
00534 <font class="preprocessor">#endif</font>
00535 <font class="preprocessor"></font>        m_freeEntries.<a class="code" href="classXalanList.html#a22">splice</a>(
00536                 m_freeEntries.<a class="code" href="classXalanList.html#a6">end</a>(), 
00537                 m_entries, 
00538                 toRemovePos.baseIterator);
00539 
00540         toRemovePos.baseIterator-&gt;erased = <font class="keyword">true</font>;
00541 
00542         --m_size;
00543     }
00544 
00545     <font class="keywordtype">void</font>
<a name="l00546"></a><a class="code" href="classXalanMap.html#b2">00546</a>     <a class="code" href="classXalanMap.html#b2">doRemoveEntries</a>()<font class="keyword"></font>
00547 <font class="keyword">    </font>{
00548         <font class="keywordflow">while</font>(<a class="code" href="classXalanMap.html#a5">size</a>() &gt; 0)
00549         {
00550             <a class="code" href="classXalanMap.html#b1">doRemoveEntry</a>(<a class="code" href="classXalanMap.html#a7">begin</a>());
00551         }
00552     }
00553 
00554     <font class="keywordtype">void</font>
<a name="l00555"></a><a class="code" href="classXalanMap.html#b3">00555</a>     <a class="code" href="classXalanMap.html#b3">doErase</a>(iterator    pos)<font class="keyword"></font>
00556 <font class="keyword">    </font>{
00557         assert(pos != <a class="code" href="classXalanMap.html#a9">end</a>());
00558 
00559         <a class="code" href="classXalanMap.html#b1">doRemoveEntry</a>(pos);
00560 
00561         ++m_eraseCount;
00562 
00563         <font class="keywordflow">if</font> (m_eraseCount == m_eraseThreshold)
00564         {
00565             <a class="code" href="classXalanMap.html#b9">compactBuckets</a>();
00566 
00567             m_eraseCount = 0;
00568         }
00569     }
00570 
00571     size_type
<a name="l00572"></a><a class="code" href="classXalanMap.html#b4">00572</a>     <a class="code" href="classXalanMap.html#b4">doHash</a>(
00573             <font class="keyword">const</font> Key&amp;  key,
00574             size_type   modulus)<font class="keyword"> const</font>
00575 <font class="keyword">    </font>{
00576         <font class="keywordflow">return</font> <a class="code" href="classXalanMap.html#n0">m_hash</a>(key) % modulus;
00577     }
00578 
<a name="l00579"></a><a class="code" href="classXalanMap.html#b5">00579</a>     size_type <a class="code" href="classXalanMap.html#b4">doHash</a>(<font class="keyword">const</font> Key &amp; key)<font class="keyword"> const</font>
00580 <font class="keyword">    </font>{
00581         <font class="keywordflow">return</font> <a class="code" href="classXalanMap.html#b4">doHash</a>(key, m_buckets.size());
00582     }
00583 
<a name="l00584"></a><a class="code" href="classXalanMap.html#b6">00584</a>     <font class="keywordtype">void</font> <a class="code" href="classXalanMap.html#b6">rehash</a>()<font class="keyword"></font>
00585 <font class="keyword">    </font>{
00586         <font class="comment">// grow the number of buckets by 60%</font>
00587         <font class="keyword">const</font> size_type     theNewSize = <a class="code" href="XalanMap_8hpp.html#a1">size_type</a>(1.6 * <a class="code" href="classXalanMap.html#a5">size</a>());
00588 
00589         BucketTableType     temp(
00590                                 theNewSize,
00591                                 <a class="code" href="classXalanMap.html#s5">BucketType</a>(*m_memoryManager),
00592                                 *m_memoryManager);
00593 
00594         <font class="comment">// rehash each entry assign to bucket and insert into list</font>
00595         EntryListIterator   entryPos = m_entries.<a class="code" href="classXalanList.html#a4">begin</a>();
00596 
00597         <font class="keywordflow">while</font> (entryPos != m_entries.<a class="code" href="classXalanList.html#a6">end</a>())
00598         {
00599             <font class="keyword">const</font> size_type     index =
00600                 <a class="code" href="classXalanMap.html#b4">doHash</a>(
00601                     entryPos-&gt;value-&gt;first,
00602                     theNewSize);
00603 
00604             temp[index].push_back(entryPos);
00605 
00606             ++entryPos;
00607         }
00608 
00609         <font class="comment">// Now that we've rebuilt the buckets, swap the rebuilt</font>
00610         <font class="comment">// buckets with our existing buckets.</font>
00611         m_buckets.swap(temp);
00612     }
00613 
00614     value_type*
<a name="l00615"></a><a class="code" href="classXalanMap.html#b7">00615</a>     <a class="code" href="classXalanMap.html#b7">allocate</a>(size_type  size)<font class="keyword"></font>
00616 <font class="keyword">    </font>{
00617         <font class="keyword">const</font> size_type     theBytesNeeded = size * <font class="keyword">sizeof</font>(value_type);
00618 
00619         assert(m_memoryManager != 0);
00620 
00621         <font class="keywordtype">void</font>*   pointer = m_memoryManager-&gt;allocate(theBytesNeeded);
00622 
00623         assert(pointer != 0);
00624 
00625         <font class="keywordflow">return</font> reinterpret_cast&lt;value_type*&gt;(pointer);
00626     }
00627 
00628     <font class="keywordtype">void</font>
<a name="l00629"></a><a class="code" href="classXalanMap.html#b8">00629</a>     <a class="code" href="classXalanMap.html#b8">deallocate</a>(value_type*  pointer)<font class="keyword"></font>
00630 <font class="keyword">    </font>{
00631         assert(m_memoryManager != 0);
00632 
00633         m_memoryManager-&gt;deallocate(pointer);
00634     }
00635 
00636     <font class="keyword">static</font> size_type
<a name="l00637"></a><a class="code" href="classXalanMap.html#e0">00637</a>     <a class="code" href="classXalanMap.html#e0">calculateNewBucketCapacity</a>(
00638             size_type   theCurrentSize,
00639             size_type   theExtraCapacity)<font class="keyword"></font>
00640 <font class="keyword">    </font>{
00641         assert(theExtraCapacity &gt; theCurrentSize);
00642 
00643         <font class="comment">// We'll use the current extra capacity a convenient number.</font>
00644         <font class="comment">// Perhaps a better choice would be to determine how much</font>
00645         <font class="comment">// of the extra capacity to keep, but we really need to</font>
00646         <font class="comment">// figure out how to keep the buckets compacted during</font>
00647         <font class="comment">// removal of an item.</font>
00648         <font class="keywordflow">return</font> theCurrentSize == 0 ?
00649                     eMinimumBucketSize :
00650                     theExtraCapacity;
00651     }
00652 
00653     <font class="keywordtype">void</font>
<a name="l00654"></a><a class="code" href="classXalanMap.html#b9">00654</a>     <a class="code" href="classXalanMap.html#b9">compactBuckets</a>()<font class="keyword"></font>
00655 <font class="keyword">    </font>{
00656         <font class="keywordflow">for</font>(TableIterator i = m_buckets.begin();
00657                 i != m_buckets.end();
00658                     ++i)
00659         {
00660             BucketType&amp;     theCurrentBucket = *i;
00661 
00662             BucketIterator  j = theCurrentBucket.begin();
00663 
00664             <font class="keywordflow">while</font>(j != theCurrentBucket.end())
00665             {
00666                 <font class="keywordflow">if</font> ((*j)-&gt;erased == <font class="keyword">true</font>)
00667                 {
00668                     j = theCurrentBucket.erase(j);
00669                 }
00670                 <font class="keywordflow">else</font>
00671                 {
00672                     ++j;
00673                 }
00674             }
00675 
00676             <font class="comment">// Now we should do something if the</font>
00677             <font class="comment">// bucket has a much greater capacity</font>
00678             <font class="comment">// than the number of items in it.</font>
00679             <font class="keyword">const</font> size_type     theCurrentSize =
00680                 theCurrentBucket.size();
00681 
00682             <font class="keyword">const</font> size_type     theExtraCapacity =
00683                 theCurrentBucket.capacity() - theCurrentSize;
00684 
00685             <font class="keywordflow">if</font> (theExtraCapacity &gt; theCurrentSize)
00686             {
00687                 <font class="keyword">const</font> size_type     theNewCapacity =
00688                     <a class="code" href="classXalanMap.html#e0">calculateNewBucketCapacity</a>(
00689                         theCurrentSize,
00690                         theExtraCapacity);
00691 
00692                 <font class="comment">// Create a copy of the bucket, and</font>
00693                 <font class="comment">// give it the new capacity of the extra</font>
00694                 <font class="comment">// capacity.</font>
00695                 BucketType  theTempBucket(
00696                                 theCurrentBucket,
00697                                 *m_memoryManager,
00698                                 theNewCapacity);
00699 
00700                 theCurrentBucket.swap(theTempBucket);
00701             }
00702         }
00703     }
00704 
00705     <font class="comment">// Data members...</font>
<a name="l00706"></a><a class="code" href="classXalanMap.html#n0">00706</a>     <font class="keyword">typename</font> KeyTraits::Hasher          m_hash;
00707         
<a name="l00708"></a><a class="code" href="classXalanMap.html#n1">00708</a>     <font class="keyword">typename</font> KeyTraits::Comparator      m_equals;
00709 
<a name="l00710"></a><a class="code" href="classXalanMap.html#n2">00710</a>     MemoryManagerType*                  m_memoryManager;
00711 
<a name="l00712"></a><a class="code" href="classXalanMap.html#n3">00712</a>     <font class="keywordtype">float</font>                               m_loadFactor;
00713 
<a name="l00714"></a><a class="code" href="classXalanMap.html#n4">00714</a>     <font class="keyword">const</font> size_type                     m_minBuckets;
00715 
<a name="l00716"></a><a class="code" href="classXalanMap.html#n5">00716</a>     size_type                           m_size;
00717 
<a name="l00718"></a><a class="code" href="classXalanMap.html#n6">00718</a>     <a class="code" href="classXalanList.html">EntryListType</a>                       m_entries;
00719 
<a name="l00720"></a><a class="code" href="classXalanMap.html#n7">00720</a>     <a class="code" href="classXalanList.html">EntryListType</a>                       m_freeEntries;
00721 
<a name="l00722"></a><a class="code" href="classXalanMap.html#n8">00722</a>     BucketTableType                     m_buckets;
00723 
<a name="l00724"></a><a class="code" href="classXalanMap.html#n9">00724</a>     size_type                           m_eraseCount;
00725     
<a name="l00726"></a><a class="code" href="classXalanMap.html#n10">00726</a>     size_type                           m_eraseThreshold;
00727 
00728 <font class="keyword">private</font>:
00729 
00730     <font class="comment">// These are not implemented.</font>
00731     <a class="code" href="classXalanMap.html#a0">XalanMap</a>();
00732 
00733     <a class="code" href="classXalanMap.html#a0">XalanMap</a>(<font class="keyword">const</font> <a class="code" href="classXalanMap.html">XalanMap</a>&amp;);
00734 };
00735 
00736 
00737 
00738 <font class="preprocessor">#if defined(_MSC_VER)</font>
00739 <font class="preprocessor"></font><font class="preprocessor">#pragma warning(pop)</font>
00740 <font class="preprocessor"></font><font class="preprocessor">#endif</font>
00741 <font class="preprocessor"></font>
00742 
00743 
00744 XALAN_CPP_NAMESPACE_END
00745 
00746 
00747 
00748 <font class="preprocessor">#endif  // XALANMAP_HEADER_GUARD_1357924680</font>
00749 <font class="preprocessor"></font>
</pre></div><p align="center"><a href="diagramnotes.html">Interpreting class diagrams</a></p>
<p><FONT color="#000000" face="arial,helvetica,sanserif" size="-1">
<i><A href="http://www.stack.nl/~dimitri/doxygen/">Doxygen</A> and 
<A href="http://www.research.att.com/sw/tools/graphviz/">GraphViz</A> are used to generate this API documentation from the Xalan-C header files.</I></FONT></p>

<TABLE border="0" cellpadding="0" cellspacing="0" width="820"><TR><TD bgcolor="#0086b2"><IMG height="1" src="../resources/dot.gif" width="1" alt="dot"></TD></TR></TABLE>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="0" WIDTH="80%">
	<TR>
		<TD WIDTH="80%" VALIGN="TOP">
			<P ALIGN="CENTER"><B>Xalan-C++ XSLT Processor Version 1.10</B><BR>
			Copyright &copy; 1999-2004 The Apache Software Foundation. All Rights Reserved.</i></p>
		</TD>
	</TR>
	<TR>
		<TD WIDTH="100%">
			<P ALIGN="CENTER"><IMG SRC="ApacheLogo.jpg" WIDTH="387" HEIGHT="100" ALIGN="BOTTOM" BORDER="0" ALT="Apache Logo">
		</TD>
	</TR>
</TABLE>
